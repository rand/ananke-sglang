{
  "version": "1.0",
  "total_examples": 147,
  "by_language": {
    "python": 18,
    "rust": 22,
    "zig": 20,
    "typescript": 22,
    "go": 22,
    "kotlin": 22,
    "swift": 21
  },
  "by_domain": {
    "types": 36,
    "imports": 21,
    "controlflow": 28,
    "semantics": 22,
    "syntax": 28,
    "comptime": 3,
    "coroutines": 5,
    "actors": 4
  },
  "examples": [
    {
      "id": "py-types-001",
      "name": "Generic Filter Function",
      "description": "Filter list while preserving type parameter T",
      "scenario": "Developer writing a generic filter function that must return the same generic type as the input. The function takes List[T] and must return List[T], not a set, tuple, or dict.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "items",
            "type_expr": "List[T]",
            "scope": "parameter"
          },
          {
            "name": "pred",
            "type_expr": "Callable[[T], bool]",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "filter_items",
            "params": [
              {
                "name": "items",
                "type_expr": "List[T]"
              },
              {
                "name": "pred",
                "type_expr": "Callable[[T], bool]"
              }
            ],
            "return_type": "List[T]",
            "type_params": [
              "T"
            ]
          }
        ],
        "expected_type": "List[T]"
      },
      "expected_effect": "Masks tokens that would produce non-List return types. Specifically blocks set comprehensions {}, dict comprehensions, tuple(), set(), and any expression that doesn't unify with List[T].",
      "valid_outputs": [
        "return [x for x in items if pred(x)]",
        "return list(filter(pred, items))",
        "return [item for item in items if pred(item)]"
      ],
      "invalid_outputs": [
        "return {x for x in items if pred(x)}",
        "return tuple(filter(pred, items))",
        "return {x: x for x in items if pred(x)}",
        "return filter(pred, items)"
      ],
      "tags": [
        "types",
        "generics",
        "inference",
        "collections"
      ],
      "language": "python",
      "domain": "types"
    },
    {
      "id": "py-types-002",
      "name": "Protocol Implementation",
      "description": "Implement duck-typed protocol with required methods",
      "scenario": "Developer implementing a Drawable protocol that requires both draw() and get_bounds() methods. The generator must complete a class that satisfies the protocol's structural requirements.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "Circle",
            "scope": "local"
          },
          {
            "name": "radius",
            "type_expr": "float",
            "scope": "local"
          }
        ],
        "expected_type": "Drawable",
        "type_aliases": {
          "Drawable": "Protocol[draw: Callable[[], None], get_bounds: Callable[[], Tuple[float, float, float, float]]]"
        }
      },
      "expected_effect": "Masks tokens that would create methods not matching the protocol. Ensures draw() has no parameters and returns None, and get_bounds() returns a 4-tuple of floats representing (x, y, width, height).",
      "valid_outputs": [
        "def draw(self) -> None:\n    print(f'Circle at radius {self.radius}')",
        "def get_bounds(self) -> Tuple[float, float, float, float]:\n    return (0.0, 0.0, self.radius * 2, self.radius * 2)"
      ],
      "invalid_outputs": [
        "def draw(self, canvas) -> None: pass",
        "def draw(self) -> str: return 'drawn'",
        "def get_bounds(self) -> Tuple[int, int]: return (0, 0)",
        "def render(self) -> None: pass"
      ],
      "tags": [
        "types",
        "protocols",
        "duck-typing",
        "structural"
      ],
      "language": "python",
      "domain": "types"
    },
    {
      "id": "py-types-003",
      "name": "Type Narrowing with isinstance",
      "description": "Narrow union type based on isinstance check",
      "scenario": "Developer handling a Union[int, str, list] type and narrowing it with isinstance checks. After checking isinstance(value, int), the type domain should recognize that value is now definitively int.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "value",
            "type_expr": "Union[int, str, list]",
            "scope": "local"
          }
        ]
      },
      "expected_effect": "After isinstance(value, int) check in the true branch, masks tokens that assume value could be str or list. Allows int-specific operations like arithmetic, bit operations, but blocks string methods like .upper() or list methods like .append().",
      "valid_outputs": [
        "if isinstance(value, int):\n    return value * 2",
        "if isinstance(value, int):\n    return value & 0xFF",
        "if isinstance(value, int):\n    return abs(value)"
      ],
      "invalid_outputs": [
        "if isinstance(value, int):\n    return value.upper()",
        "if isinstance(value, int):\n    return value.append(1)",
        "if isinstance(value, int):\n    return value + 'suffix'"
      ],
      "tags": [
        "types",
        "narrowing",
        "unions",
        "control-flow"
      ],
      "language": "python",
      "domain": "types"
    },
    {
      "id": "py-imports-001",
      "name": "Security Sandbox Environment",
      "description": "Forbid dangerous imports in sandboxed execution",
      "scenario": "Developer writing code for a sandboxed environment where filesystem, subprocess, and system operations are forbidden for security. The generator must not produce imports like os, subprocess, sys, __import__, or eval/exec calls.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "available_modules": [
          "dataclasses",
          "datetime",
          "json",
          "math",
          "re",
          "typing"
        ],
        "forbidden_imports": [
          "__builtin__",
          "builtins",
          "importlib",
          "os",
          "shutil",
          "subprocess",
          "sys"
        ]
      },
      "expected_effect": "Masks tokens that would import forbidden modules. Blocks 'import os', 'from subprocess import run', 'import sys', etc. Also blocks dynamic import patterns like __import__() and importlib.import_module().",
      "valid_outputs": [
        "import json",
        "from typing import List, Dict",
        "import math",
        "from dataclasses import dataclass"
      ],
      "invalid_outputs": [
        "import os",
        "from subprocess import run",
        "import sys",
        "from os.path import exists",
        "__import__('os')",
        "import importlib; importlib.import_module('subprocess')"
      ],
      "tags": [
        "imports",
        "security",
        "sandbox",
        "policy"
      ],
      "language": "python",
      "domain": "imports"
    },
    {
      "id": "py-imports-002",
      "name": "ML Environment Compatibility",
      "description": "Ensure numpy compatibility, forbid tensorflow for version conflicts",
      "scenario": "Developer writing code for an ML environment that uses numpy 2.x. TensorFlow is forbidden because it requires numpy 1.x and would create version conflicts. PyTorch is available and compatible.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "imports": [
          {
            "module": "numpy",
            "alias": "np"
          },
          {
            "module": "torch",
            "alias": "torch"
          }
        ],
        "available_modules": [
          "matplotlib",
          "numpy",
          "pandas",
          "scipy",
          "sklearn",
          "torch"
        ],
        "forbidden_imports": [
          "keras",
          "tensorflow",
          "tf"
        ]
      },
      "expected_effect": "Masks tokens that would import tensorflow or keras. Allows numpy, scipy, torch, and other compatible packages. Ensures that aliases like 'np' are recognized for numpy operations.",
      "valid_outputs": [
        "import numpy as np",
        "from scipy import optimize",
        "import torch",
        "from sklearn.linear_model import LinearRegression",
        "arr = np.array([1, 2, 3])"
      ],
      "invalid_outputs": [
        "import tensorflow as tf",
        "from tensorflow import keras",
        "import tf",
        "from keras.models import Sequential"
      ],
      "tags": [
        "imports",
        "ml",
        "compatibility",
        "environment"
      ],
      "language": "python",
      "domain": "imports"
    },
    {
      "id": "py-imports-003",
      "name": "TYPE_CHECKING Import Pattern",
      "description": "Type-only imports to avoid circular dependencies",
      "scenario": "Developer using the TYPE_CHECKING pattern to import types only for type annotations, avoiding circular import issues at runtime. Imports inside if TYPE_CHECKING: block should only be used in annotations, not runtime code.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "TYPE_CHECKING",
            "type_expr": "bool",
            "scope": "global"
          }
        ],
        "imports": [
          {
            "module": "typing",
            "name": "TYPE_CHECKING"
          },
          {
            "module": "typing",
            "name": "Optional"
          }
        ]
      },
      "expected_effect": "Masks runtime usage of type-only imports. Allows ForwardRef types in annotations but blocks instantiation or runtime checks. Inside if TYPE_CHECKING: block, imports are marked as annotation-only.",
      "valid_outputs": [
        "if TYPE_CHECKING:\n    from module import User\n\ndef process(user: 'User') -> None: pass",
        "if TYPE_CHECKING:\n    from circular import Node\n\nclass Tree:\n    parent: Optional['Node']"
      ],
      "invalid_outputs": [
        "if TYPE_CHECKING:\n    from module import User\n\nuser = User()",
        "if TYPE_CHECKING:\n    from module import helper\n\nhelper()"
      ],
      "tags": [
        "imports",
        "type-checking",
        "circular-deps",
        "annotations"
      ],
      "language": "python",
      "domain": "imports"
    },
    {
      "id": "py-controlflow-001",
      "name": "Async Handler Required",
      "description": "Must use await for async operations in async function",
      "scenario": "Developer writing an async HTTP handler that must await all async operations. The function is declared async, so calling other async functions without await would create unawaited coroutines.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "request",
            "type_expr": "Request",
            "scope": "parameter"
          },
          {
            "name": "db",
            "type_expr": "AsyncDatabase",
            "scope": "local"
          }
        ],
        "control_flow": {
          "function_name": "handle_request",
          "function_signature": {
            "name": "handle_request",
            "params": [
              {
                "name": "request",
                "type_expr": "Request"
              }
            ],
            "return_type": "Response",
            "is_async": true
          },
          "expected_return_type": "Response",
          "in_async_context": true
        }
      },
      "expected_effect": "Masks tokens that would call async functions without await. Blocks patterns like 'db.query()' and requires 'await db.query()'. Also blocks synchronous blocking calls like time.sleep() in favor of asyncio.sleep().",
      "valid_outputs": [
        "data = await db.query(request.user_id)",
        "result = await asyncio.gather(task1, task2)",
        "await asyncio.sleep(1.0)",
        "async with db.transaction(): pass"
      ],
      "invalid_outputs": [
        "data = db.query(request.user_id)",
        "result = asyncio.gather(task1, task2)",
        "time.sleep(1.0)"
      ],
      "tags": [
        "controlflow",
        "async",
        "await",
        "concurrency"
      ],
      "language": "python",
      "domain": "controlflow"
    },
    {
      "id": "py-controlflow-002",
      "name": "Loop Context with break/continue",
      "description": "Allow break/continue only inside loops",
      "scenario": "Developer writing code inside a loop where break and continue are valid control flow statements. Outside loops, these statements would be syntax errors.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "items",
            "type_expr": "List[str]",
            "scope": "local"
          },
          {
            "name": "item",
            "type_expr": "str",
            "scope": "local"
          },
          {
            "name": "index",
            "type_expr": "int",
            "scope": "local"
          }
        ],
        "control_flow": {
          "function_name": "process_items",
          "loop_depth": 1,
          "loop_variables": [
            "item",
            "index"
          ]
        }
      },
      "expected_effect": "When loop_depth > 0, allows break and continue statements. Masks these tokens when loop_depth == 0. Also tracks loop variables for scope analysis.",
      "valid_outputs": [
        "if item == 'skip': continue",
        "if item == 'stop': break",
        "if index > 100: break"
      ],
      "invalid_outputs": [
        "return item",
        "raise StopIteration",
        "items.remove(item)"
      ],
      "tags": [
        "controlflow",
        "loops",
        "break",
        "continue"
      ],
      "language": "python",
      "domain": "controlflow"
    },
    {
      "id": "py-controlflow-003",
      "name": "Try Block Exception Handling",
      "description": "Handle specific exception types in try/except block",
      "scenario": "Developer writing error handling code inside a try block where specific exception types are expected. The except clauses should only catch IOError and ValueError, not broad Exception.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "config_path",
            "type_expr": "str",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "read_config",
          "expected_return_type": "Optional[Config]",
          "in_try_block": true,
          "exception_types": [
            "IOError",
            "ValueError"
          ]
        }
      },
      "expected_effect": "Masks overly broad exception catching. Blocks 'except Exception:', 'except BaseException:', and bare 'except:'. Allows only the specific exception types listed in exception_types tuple.",
      "valid_outputs": [
        "except IOError as e:\n    return None",
        "except ValueError as e:\n    logging.error(f'Invalid config: {e}')\n    return None",
        "except (IOError, ValueError) as e:\n    return None"
      ],
      "invalid_outputs": [
        "except Exception as e: pass",
        "except BaseException as e: pass",
        "except: pass",
        "except KeyError as e: pass"
      ],
      "tags": [
        "controlflow",
        "exceptions",
        "error-handling",
        "try-except"
      ],
      "language": "python",
      "domain": "controlflow"
    },
    {
      "id": "py-semantics-001",
      "name": "Non-Negative Result Postcondition",
      "description": "Ensure function result is always non-negative",
      "scenario": "Developer writing an absolute value or distance function that must guarantee a non-negative result. The semantic domain verifies that all code paths produce result >= 0.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "x1",
            "type_expr": "float",
            "scope": "parameter"
          },
          {
            "name": "y1",
            "type_expr": "float",
            "scope": "parameter"
          },
          {
            "name": "x2",
            "type_expr": "float",
            "scope": "parameter"
          },
          {
            "name": "y2",
            "type_expr": "float",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "compute_distance",
            "params": [
              {
                "name": "x1",
                "type_expr": "float"
              },
              {
                "name": "y1",
                "type_expr": "float"
              },
              {
                "name": "x2",
                "type_expr": "float"
              },
              {
                "name": "y2",
                "type_expr": "float"
              }
            ],
            "return_type": "float"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "result >= 0",
            "scope": "compute_distance",
            "variables": [
              "result"
            ]
          }
        ]
      },
      "expected_effect": "Masks expressions that could produce negative results. Blocks direct subtraction without abs(), allows sqrt() and abs() which guarantee non-negative outputs. Uses SMT solver to prove result >= 0.",
      "valid_outputs": [
        "return abs(x2 - x1) + abs(y2 - y1)",
        "return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)",
        "return max(0, x2 - x1)"
      ],
      "invalid_outputs": [
        "return x2 - x1",
        "return (x2 - x1) + (y2 - y1)",
        "return -abs(x2 - x1)"
      ],
      "tags": [
        "semantics",
        "postcondition",
        "smt",
        "verification"
      ],
      "language": "python",
      "domain": "semantics"
    },
    {
      "id": "py-semantics-002",
      "name": "Array Bounds Check Precondition",
      "description": "Verify index is within array bounds before access",
      "scenario": "Developer writing array indexing code that must verify bounds before access. The semantic domain checks that 0 <= index < len(array) is proven before any array[index] access.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "items",
            "type_expr": "List[int]",
            "scope": "parameter"
          },
          {
            "name": "index",
            "type_expr": "int",
            "scope": "parameter"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "0 <= index < len(items)",
            "scope": "get_item",
            "variables": [
              "index",
              "items"
            ]
          }
        ]
      },
      "expected_effect": "Masks direct array access items[index] unless bounds check is proven. Requires explicit check like 'if 0 <= index < len(items):' or 'assert 0 <= index < len(items)' before access. Uses SMT to track bounds in control flow.",
      "valid_outputs": [
        "if 0 <= index < len(items):\n    return items[index]\nreturn None",
        "assert 0 <= index < len(items), 'Index out of bounds'\nreturn items[index]",
        "if index < 0 or index >= len(items):\n    raise IndexError\nreturn items[index]"
      ],
      "invalid_outputs": [
        "return items[index]",
        "if index >= 0:\n    return items[index]",
        "return items[min(index, 100)]"
      ],
      "tags": [
        "semantics",
        "precondition",
        "bounds-check",
        "safety"
      ],
      "language": "python",
      "domain": "semantics"
    },
    {
      "id": "py-semantics-003",
      "name": "Class Invariant Balance Non-Negative",
      "description": "Maintain class invariant that balance >= 0",
      "scenario": "Developer writing a BankAccount class where the invariant 'balance >= 0' must hold after every method. The withdraw() method must check that sufficient funds exist before deducting.",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "self.balance",
            "type_expr": "float",
            "scope": "class:BankAccount"
          },
          {
            "name": "amount",
            "type_expr": "float",
            "scope": "parameter"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "self.balance >= 0",
            "scope": "BankAccount",
            "variables": [
              "self.balance"
            ]
          }
        ]
      },
      "expected_effect": "Masks operations that could violate the invariant. In withdraw(), blocks 'self.balance -= amount' unless proven that amount <= self.balance. Requires explicit check or exception raising when invariant would break.",
      "valid_outputs": [
        "def withdraw(self, amount: float) -> bool:\n    if amount <= self.balance:\n        self.balance -= amount\n        return True\n    return False",
        "def withdraw(self, amount: float) -> None:\n    if amount > self.balance:\n        raise InsufficientFundsError\n    self.balance -= amount"
      ],
      "invalid_outputs": [
        "def withdraw(self, amount: float) -> None:\n    self.balance -= amount",
        "def withdraw(self, amount: float) -> None:\n    if amount > 0:\n        self.balance -= amount"
      ],
      "tags": [
        "semantics",
        "invariant",
        "class",
        "state"
      ],
      "language": "python",
      "domain": "semantics"
    },
    {
      "id": "py-syntax-001",
      "name": "JSON API Response Schema",
      "description": "Generate JSON response matching API schema",
      "scenario": "Developer generating a JSON API response that must match the expected schema: {\"status\": \"ok\" | \"error\", \"data\": {...}, \"message\": string?}. The response must be valid JSON and include required fields.",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"enum\": [\"ok\", \"error\"]\n        },\n        \"data\": {\n            \"type\": \"object\"\n        },\n        \"message\": {\n            \"type\": \"string\"\n        }\n    },\n    \"required\": [\"status\", \"data\"],\n    \"additionalProperties\": false\n}",
        "language": "python"
      },
      "expected_effect": "Masks tokens that would produce invalid JSON or schema violations. Ensures 'status' is exactly 'ok' or 'error', 'data' is an object, and no additional fields beyond status/data/message appear.",
      "valid_outputs": [
        "{\"status\": \"ok\", \"data\": {\"items\": [1, 2, 3]}}",
        "{\"status\": \"error\", \"data\": {}, \"message\": \"Not found\"}",
        "{\"status\": \"ok\", \"data\": {\"user\": {\"id\": 123, \"name\": \"Alice\"}}}"
      ],
      "invalid_outputs": [
        "{\"status\": \"success\", \"data\": {}}",
        "{\"status\": \"ok\"}",
        "{\"status\": \"ok\", \"data\": [], \"extra\": \"field\"}",
        "{\"status\": \"ok\", \"data\": null}"
      ],
      "tags": [
        "syntax",
        "json-schema",
        "api",
        "validation"
      ],
      "language": "python",
      "domain": "syntax"
    },
    {
      "id": "py-syntax-002",
      "name": "Email Validation Regex",
      "description": "Generate email address matching RFC-like pattern",
      "scenario": "Developer generating email addresses for testing that must match a realistic email pattern: username@domain.tld where username is alphanumeric with dots/underscores, domain is alphanumeric with hyphens, and TLD is 2-6 letters.",
      "spec": {
        "version": "1.0",
        "regex": "^[a-zA-Z0-9._+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$",
        "language": "python"
      },
      "expected_effect": "Masks tokens that would produce invalid email formats. Ensures proper structure with @ separator, valid characters in username and domain, and TLD of appropriate length.",
      "valid_outputs": [
        "alice@example.com",
        "bob.smith@company.co.uk",
        "user_123@sub-domain.example.org",
        "test+tag@domain.io"
      ],
      "invalid_outputs": [
        "notanemail",
        "@example.com",
        "user@",
        "user@domain",
        "user@domain.c",
        "user@domain.toolongtld",
        "user name@domain.com"
      ],
      "tags": [
        "syntax",
        "regex",
        "validation",
        "email"
      ],
      "language": "python",
      "domain": "syntax"
    },
    {
      "id": "py-syntax-003",
      "name": "SQL SELECT Statement EBNF",
      "description": "Generate SQL SELECT statement following DSL grammar",
      "scenario": "Developer generating SQL SELECT queries for a query builder DSL. The grammar enforces structure: SELECT columns FROM table [WHERE condition] [ORDER BY column]. Must be valid according to simplified SQL EBNF.",
      "spec": {
        "version": "1.0",
        "ebnf": "\nselect_stmt = \"SELECT\", column_list, \"FROM\", identifier, [where_clause], [order_clause];\ncolumn_list = identifier, {\",\", identifier} | \"*\";\nwhere_clause = \"WHERE\", condition;\norder_clause = \"ORDER BY\", identifier, [\"ASC\" | \"DESC\"];\ncondition = identifier, operator, value;\noperator = \"=\" | \"!=\" | \">\" | \"<\" | \">=\" | \"<=\";\nidentifier = letter, {letter | digit | \"_\"};\nvalue = number | string;\nnumber = digit, {digit};\nstring = \"'\", {any_char - \"'\"}, \"'\";\nletter = \"a\" | \"b\" | ... | \"z\" | \"A\" | ... | \"Z\";\ndigit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\";\n",
        "language": "python"
      },
      "expected_effect": "Masks tokens that would produce invalid SQL according to the grammar. Enforces correct keyword order (SELECT before FROM), proper column/table identifiers, and optional WHERE/ORDER BY clauses in correct positions.",
      "valid_outputs": [
        "SELECT * FROM users",
        "SELECT id, name FROM users WHERE age > 18",
        "SELECT name FROM products ORDER BY price DESC",
        "SELECT username, email FROM accounts WHERE active = 1 ORDER BY created_at ASC"
      ],
      "invalid_outputs": [
        "SELECT FROM users",
        "FROM users SELECT *",
        "SELECT * FROM",
        "SELECT * FROM users WHERE",
        "SELECT * FROM users ORDER",
        "SELECT * FROM users LIMIT 10"
      ],
      "tags": [
        "syntax",
        "ebnf",
        "dsl",
        "sql"
      ],
      "language": "python",
      "domain": "syntax"
    },
    {
      "id": "py-deep-001",
      "name": "Validated User Dataclass",
      "description": "Dataclass with field validators and __post_init__ validation",
      "scenario": "Developer creating a User dataclass with validation constraints:\n1. Email must match regex pattern\n2. Age must be between 0 and 150 (semantic constraint)\n3. Username must be 3-20 alphanumeric characters\n4. Created_at must use datetime.datetime type\n5. __post_init__ validates all fields and raises on invalid data\n\nThis example demonstrates cross-domain constraint propagation where:\n- TypeDomain ensures proper dataclass field types\n- ImportDomain provides dataclasses and datetime modules\n- SemanticDomain enforces age range invariants\n- SyntaxDomain validates email and username patterns\n- ControlFlowDomain ensures __post_init__ properly validates",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "User",
            "scope": "class:User"
          },
          {
            "name": "username",
            "type_expr": "str",
            "scope": "class:User"
          },
          {
            "name": "email",
            "type_expr": "str",
            "scope": "class:User"
          },
          {
            "name": "age",
            "type_expr": "int",
            "scope": "class:User"
          },
          {
            "name": "created_at",
            "type_expr": "datetime",
            "scope": "class:User"
          }
        ],
        "class_definitions": [
          {
            "name": "User",
            "methods": [
              {
                "name": "__post_init__",
                "params": [
                  {
                    "name": "self",
                    "type_expr": "User"
                  }
                ],
                "return_type": "None"
              }
            ],
            "instance_vars": [
              {
                "name": "username",
                "type_expr": "str"
              },
              {
                "name": "email",
                "type_expr": "str"
              },
              {
                "name": "age",
                "type_expr": "int"
              },
              {
                "name": "created_at",
                "type_expr": "datetime"
              }
            ]
          }
        ],
        "imports": [
          {
            "module": "dataclasses",
            "name": "dataclass"
          },
          {
            "module": "dataclasses",
            "name": "field"
          },
          {
            "module": "datetime",
            "name": "datetime"
          },
          {
            "module": "re"
          }
        ],
        "available_modules": [
          "dataclasses",
          "datetime",
          "re",
          "typing"
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "0 <= self.age <= 150",
            "scope": "User",
            "variables": [
              "self.age"
            ]
          },
          {
            "kind": "precondition",
            "expression": "len(self.username) >= 3 and len(self.username) <= 20",
            "scope": "User.__post_init__",
            "variables": [
              "self.username"
            ]
          }
        ]
      },
      "expected_effect": "Combined masking from all domains:\n1. TypeDomain masks non-str for username/email, non-int for age, non-datetime for created_at\n2. ImportDomain ensures dataclasses/datetime imports are available\n3. SemanticDomain masks age assignments outside 0-150 range\n4. SyntaxDomain (via regex in validation) ensures email format\n5. ControlFlowDomain ensures __post_init__ raises ValueError on validation failure\n\nThe domains propagate constraints to each other:\n- Type constraints inform semantic checks (age is int, so numeric comparisons work)\n- Semantic constraints refine type domain (age is not just int, but 0-150)\n- Import availability affects what validators can be written",
      "valid_outputs": [
        "@dataclass\nclass User:\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n\n    def __post_init__(self):\n        if not (3 <= len(self.username) <= 20):\n            raise ValueError(\"Username must be 3-20 characters\")\n        if not re.match(r'^[a-zA-Z0-9._+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$', self.email):\n            raise ValueError(\"Invalid email format\")\n        if not (0 <= self.age <= 150):\n            raise ValueError(\"Age must be between 0 and 150\")",
        "@dataclass\nclass User:\n    username: str\n    email: str\n    age: int\n    created_at: datetime = field(default_factory=datetime.now)\n\n    def __post_init__(self):\n        # Validate username length\n        if len(self.username) < 3 or len(self.username) > 20:\n            raise ValueError(f\"Username '{self.username}' must be 3-20 characters\")\n\n        # Validate email pattern\n        email_pattern = r'^[a-zA-Z0-9._+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$'\n        if not re.match(email_pattern, self.email):\n            raise ValueError(f\"Invalid email: {self.email}\")\n\n        # Validate age range\n        if self.age < 0 or self.age > 150:\n            raise ValueError(f\"Age {self.age} is out of valid range (0-150)\")"
      ],
      "invalid_outputs": [
        "@dataclass\nclass User:\n    username: int  # Wrong type\n    email: str\n    age: int\n    created_at: datetime",
        "@dataclass\nclass User:\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n\n    def __post_init__(self):\n        pass  # No validation",
        "@dataclass\nclass User:\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n\n    def __post_init__(self):\n        if self.age < 0 or self.age > 200:  # Wrong upper bound\n            raise ValueError(\"Invalid age\")",
        "# No dataclass import\nclass User:\n    def __init__(self, username: str, email: str, age: int, created_at: datetime):\n        self.username = username\n        self.email = email\n        self.age = age\n        self.created_at = created_at",
        "@dataclass\nclass User:\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n\n    def __post_init__(self):\n        if len(self.username) < 3:  # Missing upper bound check\n            raise ValueError(\"Username too short\")"
      ],
      "tags": [
        "types",
        "semantics",
        "syntax",
        "imports",
        "dataclass",
        "validation",
        "cross-domain",
        "deep-dive"
      ],
      "language": "python",
      "domain": "types"
    },
    {
      "id": "rust-types-001",
      "name": "Ownership Transfer with Box<T>",
      "description": "Constraint generation for move semantics with heap-allocated Box<T>",
      "scenario": "Developer implementing a binary tree where nodes own their children. The function must return a boxed node, transferring ownership to caller. The constraint ensures generated code respects move semantics and heap allocation.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"Box::new(Node \" \"{\" \" value\" (\",\" \" left\" | \",\" \" right\")* \" })\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "value",
            "type_expr": "i32",
            "scope": "parameter",
            "mutable": false
          },
          {
            "name": "left",
            "type_expr": "Option<Box<Node>>",
            "scope": "parameter",
            "mutable": false
          },
          {
            "name": "right",
            "type_expr": "Option<Box<Node>>",
            "scope": "parameter",
            "mutable": false
          }
        ],
        "expected_type": "Box<Node>",
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "result.is_valid_heap_allocation()",
            "scope": "create_node",
            "variables": [
              "result"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would violate ownership rules or produce stack-allocated structures. Ensures Box::new wraps the value and enforces move semantics.",
      "valid_outputs": [
        "Box::new(Node { value, left, right })",
        "Box::new(Node { value, left: None, right: None })",
        "Box::new(Node { value: value, left: left, right: right })"
      ],
      "invalid_outputs": [
        "Node { value, left, right }",
        "&Node { value, left, right }",
        "Box::from_raw(ptr)"
      ],
      "tags": [
        "types",
        "ownership",
        "heap",
        "box",
        "move"
      ],
      "language": "rust",
      "domain": "types"
    },
    {
      "id": "rust-types-002",
      "name": "Lifetime-Bounded Reference",
      "description": "Constraint generation for explicit lifetime parameters in function signatures",
      "scenario": "Developer writing a function that returns a reference to data within a struct. The lifetime 'a must be explicit to tie the output lifetime to input. The constraint ensures the generated signature prevents dangling references.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"&\" \"data\" \".\" \"name\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "data",
            "type_expr": "&'a Data",
            "scope": "parameter",
            "mutable": false
          }
        ],
        "expected_type": "&'a str",
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "result.lifetime <= data.lifetime",
            "scope": "get_name",
            "variables": [
              "result",
              "data"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens producing owned String or 'static lifetimes that would outlive the borrow. Enforces that returned reference lifetime is tied to input 'a.",
      "valid_outputs": [
        "&data.name",
        "&data.name[..]",
        "data.name.as_str()"
      ],
      "invalid_outputs": [
        "data.name.clone()",
        "data.name.to_string()",
        "&STATIC_NAME"
      ],
      "tags": [
        "types",
        "lifetimes",
        "borrowing",
        "references"
      ],
      "language": "rust",
      "domain": "types"
    },
    {
      "id": "rust-types-003",
      "name": "Trait Bounds with Multiple Constraints",
      "description": "Constraint generation for generic functions with trait bound requirements",
      "scenario": "Developer implementing a generic sort-and-debug function. The type T must implement Ord for comparison, Debug for printing, and Clone for duplication. The constraint ensures all trait bounds are satisfied in generated code.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"items\" \".\" \"sort\" \"()\" \";\" ws \"items\" \".\" \"iter\" \"()\" \".\" method-chain\n        method-chain ::= \"cloned\" \"()\" \".\" \"collect\" \"()\"\n        ws ::= \" \" | \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "items",
            "type_expr": "&mut [T]",
            "scope": "parameter"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "T: Ord + Debug + Clone",
            "scope": "sort_and_debug",
            "variables": [
              "T"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that call methods not available on T given the trait bounds. Ensures sort() is called (Ord), iter() works (slice), and cloned() succeeds (Clone).",
      "valid_outputs": [
        "items.sort();\nitems.iter().cloned().collect()",
        "items.sort_unstable();\nitems.iter().cloned().collect::<Vec<_>>()",
        "items.sort_by(|a, b| a.cmp(b));\nitems.iter().map(|x| x.clone()).collect()"
      ],
      "invalid_outputs": [
        "items.sort();\nitems.to_vec()",
        "items.sort();\nitems.iter().collect()",
        "items.hash();\nitems.clone()"
      ],
      "tags": [
        "types",
        "generics",
        "trait-bounds",
        "constraints"
      ],
      "language": "rust",
      "domain": "types"
    },
    {
      "id": "rust-imports-001",
      "name": "no_std Environment Constraint",
      "description": "Constraint generation for embedded/kernel code forbidding std library",
      "scenario": "Developer writing embedded firmware for a microcontroller without OS support. The code must compile with #![no_std], forbidding any std::* imports. The constraint ensures generated code only uses core:: and alloc:: when needed.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"use \" module \"::\" item \";\"\n        module ::= \"core\" | \"alloc\"\n        item ::= [a-zA-Z_][a-zA-Z0-9_]*\n        ",
        "language": "rust",
        "imports": [
          {
            "module": "core::fmt",
            "name": "Write"
          },
          {
            "module": "core::ptr"
          },
          {
            "module": "alloc::vec",
            "name": "Vec"
          },
          {
            "module": "alloc::string",
            "name": "String"
          }
        ],
        "forbidden_imports": [
          "std",
          "std::*"
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "!uses_std_features()",
            "scope": "module"
          }
        ]
      },
      "expected_effect": "Masks tokens that would import std:: modules or use std-only features like std::io, std::fs, or std::thread. Allows core:: (always available) and alloc:: (if allocator provided).",
      "valid_outputs": [
        "use core::fmt::Write;",
        "use alloc::vec::Vec;",
        "use core::ptr::write_volatile;",
        "use alloc::string::String;"
      ],
      "invalid_outputs": [
        "use std::vec::Vec;",
        "use std::io::Write;",
        "use std::collections::HashMap;"
      ],
      "tags": [
        "imports",
        "no_std",
        "embedded",
        "kernel"
      ],
      "language": "rust",
      "domain": "imports"
    },
    {
      "id": "rust-imports-002",
      "name": "Unsafe Library Restriction",
      "description": "Constraint generation forbidding direct unsafe FFI dependencies",
      "scenario": "Developer working in a memory-safe codebase where direct libc usage is banned. All system calls must go through safe wrappers like std::fs or nix crate. The constraint prevents importing raw libc functions that bypass safety.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"use \" safe-module \"::\" item \";\"\n        safe-module ::= \"std::\" [a-z]+ | \"nix::\" [a-z]+\n        item ::= [a-zA-Z_][a-zA-Z0-9_]*\n        ",
        "language": "rust",
        "imports": [
          {
            "module": "std::fs",
            "name": "File"
          },
          {
            "module": "std::io",
            "name": "Read"
          },
          {
            "module": "nix::unistd",
            "name": "read"
          }
        ],
        "forbidden_imports": [
          "libc",
          "libc::*",
          "winapi::um::*"
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "!contains_unsafe_blocks() || has_safety_comment()",
            "scope": "module"
          }
        ]
      },
      "expected_effect": "Masks tokens importing libc or winapi directly. Forces use of safe wrappers from std or crates like nix that provide memory-safe interfaces to system calls.",
      "valid_outputs": [
        "use std::fs::OpenOptions;",
        "use std::os::unix::io::AsRawFd;",
        "use nix::sys::socket::socket;",
        "use std::io::{Read, Write};"
      ],
      "invalid_outputs": [
        "use libc::read;",
        "use libc::c_char;",
        "use winapi::um::fileapi::ReadFile;"
      ],
      "tags": [
        "imports",
        "safety",
        "unsafe",
        "ffi"
      ],
      "language": "rust",
      "domain": "imports"
    },
    {
      "id": "rust-imports-003",
      "name": "Feature-Gated Crate Dependencies",
      "description": "Constraint generation for imports only allowed under feature flags",
      "scenario": "Developer implementing optional functionality that requires heavy dependencies. The code should only import serde and tokio when their feature flags are enabled. The constraint ensures generated imports are guarded by cfg attributes.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= cfg-attr? \"use \" module \"::\" item \";\"\n        cfg-attr ::= \"#[cfg(feature = \\\"\" feature-name \"\\\")]\" ws\n        feature-name ::= \"serde\" | \"async\"\n        module ::= \"serde\" | \"tokio::\" [a-z_]+\n        item ::= [a-zA-Z_][a-zA-Z0-9_]*\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "imports": [
          {
            "module": "serde",
            "name": "Serialize"
          },
          {
            "module": "serde",
            "name": "Deserialize"
          },
          {
            "module": "tokio::runtime",
            "name": "Runtime"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "feature_enabled(\"serde\") || feature_enabled(\"async\")",
            "scope": "module"
          }
        ]
      },
      "expected_effect": "Masks tokens that import feature-gated dependencies without cfg guards. Ensures serde imports have #[cfg(feature = \"serde\")] and tokio has #[cfg(feature = \"async\")].",
      "valid_outputs": [
        "#[cfg(feature = \"serde\")]\nuse serde::{Serialize, Deserialize};",
        "#[cfg(feature = \"async\")]\nuse tokio::runtime::Runtime;",
        "#[cfg(feature = \"serde\")]\nuse serde::de::DeserializeOwned;"
      ],
      "invalid_outputs": [
        "use serde::Serialize;",
        "use tokio::runtime::Runtime;",
        "#[cfg(test)]\nuse serde::Serialize;"
      ],
      "tags": [
        "imports",
        "features",
        "conditional",
        "cfg"
      ],
      "language": "rust",
      "domain": "imports"
    },
    {
      "id": "rust-controlflow-001",
      "name": "Match Exhaustiveness with Enums",
      "description": "Constraint generation ensuring all enum variants are handled in match",
      "scenario": "Developer implementing command processing for an enum with multiple variants. Rust requires exhaustive matching, so all variants must be covered. The constraint ensures generated match arms handle every case without wildcard.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"match cmd {\" ws arms ws \"}\"\n        arms ::= arm (ws arm)*\n        arm ::= \"Command::\" variant \"(\" params? \")\" \" => \" body \",\"\n        variant ::= \"Start\" | \"Stop\" | \"Restart\" | \"Status\"\n        params ::= [a-z_]+\n        body ::= \"Ok(())\" | \"Err(\" [^,]+ \")\"\n        ws ::= \" \" | \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "cmd",
            "type_expr": "Command",
            "scope": "parameter",
            "mutable": false
          }
        ],
        "control_flow": {
          "function_name": "execute_command",
          "expected_return_type": "Result<(), Error>"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "all_variants_covered(match_expr)",
            "scope": "execute_command",
            "variables": [
              "match_expr"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that use _ wildcard or omit enum variants. Enforces explicit handling of Command::Start, Stop, Restart, and Status without catch-all.",
      "valid_outputs": [
        "match cmd {\n    Command::Start(id) => Ok(()),\n    Command::Stop(id) => Ok(()),\n    Command::Restart(id) => Ok(()),\n    Command::Status => Ok(()),\n}",
        "match cmd {\n    Command::Start(_) => start_service(),\n    Command::Stop(_) => stop_service(),\n    Command::Restart(_) => restart_service(),\n    Command::Status => get_status(),\n}"
      ],
      "invalid_outputs": [
        "match cmd {\n    Command::Start(id) => Ok(()),\n    _ => Err(Error::Unknown),\n}",
        "match cmd {\n    Command::Start(id) => Ok(()),\n    Command::Stop(id) => Ok(()),\n}"
      ],
      "tags": [
        "controlflow",
        "match",
        "exhaustiveness",
        "enums"
      ],
      "language": "rust",
      "domain": "controlflow"
    },
    {
      "id": "rust-controlflow-002",
      "name": "Question Mark Operator in Result Context",
      "description": "Constraint generation for ? operator with proper Result propagation",
      "scenario": "Developer writing a function that calls multiple fallible operations. The ? operator propagates errors automatically but requires Result return type. The constraint ensures ? is used correctly and errors are compatible.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= statement+ final-statement\n        statement ::= \"let \" var \" = \" expr \"?;\" ws\n        final-statement ::= \"Ok(\" expr \")\"\n        expr ::= \"File::open(\" arg \")\" | \"read_to_string(\" arg \")\" | var \".\" method-call\n        method-call ::= [a-z_]+ \"(\" args? \")\"\n        var ::= [a-z_]+\n        arg ::= [a-z_]+\n        args ::= arg | arg \", \" args\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "path",
            "type_expr": "&Path",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "load_config",
          "function_signature": {
            "name": "load_config",
            "params": [
              {
                "name": "path",
                "type_expr": "&Path",
                "scope": "parameter"
              }
            ],
            "return_type": "Result<Config, io::Error>"
          },
          "expected_return_type": "Result<Config, io::Error>"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "error_type_compatible(fn_error, op_error)",
            "scope": "load_config",
            "variables": [
              "fn_error",
              "op_error"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that use unwrap() or expect() instead of ?. Ensures all fallible operations use ? for error propagation and final value is wrapped in Ok().",
      "valid_outputs": [
        "let file = File::open(path)?;\nlet contents = read_to_string(file)?;\nOk(parse_config(&contents)?)",
        "let mut file = File::open(path)?;\nlet mut buf = String::new();\nfile.read_to_string(&mut buf)?;\nOk(Config::parse(&buf)?)"
      ],
      "invalid_outputs": [
        "let file = File::open(path).unwrap();\nOk(parse_config(&file))",
        "let file = File::open(path)?;\nparse_config(&file)",
        "File::open(path)?"
      ],
      "tags": [
        "controlflow",
        "error-handling",
        "result",
        "question-mark"
      ],
      "language": "rust",
      "domain": "controlflow"
    },
    {
      "id": "rust-controlflow-003",
      "name": "Early Return with Guard Clauses",
      "description": "Constraint generation for guard clause pattern with early returns",
      "scenario": "Developer implementing validation logic with multiple preconditions. Guard clauses check conditions early and return errors, avoiding nested ifs. The constraint ensures each guard returns appropriate error without continuing.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= guard+ success-return\n        guard ::= \"if \" condition \" {\" ws \"return Err(\" error \");\" ws \"}\" ws\n        condition ::= var \".\" accessor \" \" op \" \" value\n        accessor ::= \"name\" | \"email\" | \"age\"\n        op ::= \"==\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\"\n        value ::= \"\\\"\\\"\\\"\" | [0-9]+\n        error ::= \"ValidationError::\" [a-zA-Z]+\n        success-return ::= \"Ok(())\"\n        var ::= \"user\"\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "user",
            "type_expr": "&User",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "validate_user",
          "expected_return_type": "Result<(), ValidationError>"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "every_guard_returns()",
            "scope": "validate_user"
          }
        ]
      },
      "expected_effect": "Masks tokens that continue execution after failed validation. Ensures each guard clause has an explicit return Err() and success path returns Ok(()) at the end.",
      "valid_outputs": [
        "if user.name == \"\" {\n    return Err(ValidationError::EmptyName);\n}\nif user.age < 18 {\n    return Err(ValidationError::TooYoung);\n}\nOk(())",
        "if user.email == \"\" {\n    return Err(ValidationError::NoEmail);\n}\nif user.name == \"\" {\n    return Err(ValidationError::NoName);\n}\nOk(())"
      ],
      "invalid_outputs": [
        "if user.name == \"\" {\n    ValidationError::EmptyName\n}\nOk(())",
        "if user.age < 18 {\n    return Err(ValidationError::TooYoung);\n}",
        "user.name != \"\" && user.age >= 18"
      ],
      "tags": [
        "controlflow",
        "guards",
        "early-return",
        "validation"
      ],
      "language": "rust",
      "domain": "controlflow"
    },
    {
      "id": "rust-semantics-001",
      "name": "No-Panic Guarantee",
      "description": "Constraint generation forbidding panic-inducing operations",
      "scenario": "Developer implementing code for a safety-critical system where panics are forbidden. All operations must return Result or Option instead of panicking on failure. The constraint masks unwrap(), expect(), panic!(), and unchecked indexing.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"items\" \".\" method \"(\" args? \")\"\n        method ::= \"get\" | \"get_mut\" | \"iter\" | \"first\" | \"last\"\n        args ::= \"key\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "items",
            "type_expr": "Vec<T>",
            "scope": "parameter"
          },
          {
            "name": "key",
            "type_expr": "usize",
            "scope": "parameter"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "!contains_panic_sources()",
            "scope": "get_item"
          }
        ]
      },
      "expected_effect": "Masks tokens producing unwrap(), expect(), panic!(), or indexing with []. Enforces safe methods like get() that return Option, never panicking.",
      "valid_outputs": [
        "items.get(key)",
        "items.get(key).ok_or(Error::NotFound)",
        "items.get(key).copied()",
        "items.first()"
      ],
      "invalid_outputs": [
        "items[key]",
        "items.get(key).unwrap()",
        "items.get(key).expect(\"must exist\")",
        "items[key].clone()"
      ],
      "tags": [
        "semantics",
        "panic",
        "safety",
        "no-panic"
      ],
      "language": "rust",
      "domain": "semantics"
    },
    {
      "id": "rust-semantics-002",
      "name": "Memory Safety Invariant",
      "description": "Constraint generation ensuring memory safety invariants in unsafe code",
      "scenario": "Developer implementing a custom allocator that must maintain safety invariants. When working with raw pointers, alignment and non-null guarantees must hold. The constraint ensures checks are present before dereferencing raw pointers.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= guards ws \"unsafe {\" ws \"// SAFETY:\" safety-comment ws operation ws \"}\"\n        guards ::= guard (ws guard)*\n        guard ::= \"if \" condition \" {\" ws \"return Err(\" error \");\" ws \"}\"\n        condition ::= \"ptr.is_null()\" | \"!ptr.is_aligned()\"\n        error ::= \"Error::\" [a-zA-Z]+\n        safety-comment ::= \" \" [^\\n]+\n        operation ::= \"ptr.write(value)\"\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "ptr",
            "type_expr": "*mut T",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "write_value"
        },
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "!ptr.is_null() && ptr.is_aligned()",
            "scope": "write_value",
            "variables": [
              "ptr"
            ]
          },
          {
            "kind": "invariant",
            "expression": "unsafe_blocks_have_safety_comments()",
            "scope": "write_value"
          }
        ]
      },
      "expected_effect": "Masks tokens that dereference raw pointers without null/alignment checks. Ensures unsafe blocks have SAFETY comments documenting invariants upheld.",
      "valid_outputs": [
        "if ptr.is_null() {\n    return Err(Error::NullPtr);\n}\nif !ptr.is_aligned() {\n    return Err(Error::Misaligned);\n}\nunsafe {\n// SAFETY: ptr is non-null and aligned as checked above\n    ptr.write(value)\n}",
        "if ptr.is_null() {\n    return Err(Error::Null);\n}\nunsafe {\n// SAFETY: ptr is non-null and write is within allocation bounds\n    ptr.write(value)\n}"
      ],
      "invalid_outputs": [
        "unsafe { ptr.write(value) }",
        "unsafe {\n    ptr.write(value)\n}",
        "if ptr.is_null() { return Err(Error::Null); }\nunsafe { ptr.write(value) }"
      ],
      "tags": [
        "semantics",
        "unsafe",
        "memory-safety",
        "invariants"
      ],
      "language": "rust",
      "domain": "semantics"
    },
    {
      "id": "rust-semantics-003",
      "name": "Unsafe Block with Safety Comment Requirement",
      "description": "Constraint generation requiring documentation for all unsafe blocks",
      "scenario": "Developer implementing FFI bindings to a C library. Every unsafe block must document why it's safe, what invariants it relies on, and what could go wrong. The constraint ensures unsafe code has mandatory SAFETY comments.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"unsafe {\" ws comment ws operation ws \"}\"\n        comment ::= \"// SAFETY:\" explanation\n        explanation ::= \" \" [^\\n]{20,}\n        operation ::= \"libc::close(fd)\"\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "fd",
            "type_expr": "RawFd",
            "scope": "parameter"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "unsafe_block_has_safety_doc()",
            "scope": "close_fd"
          }
        ]
      },
      "expected_effect": "Masks tokens producing unsafe blocks without // SAFETY: comment preceding the unsafe operation. Enforces documentation of safety reasoning.",
      "valid_outputs": [
        "unsafe {\n// SAFETY: fd is a valid file descriptor obtained from open() and has not been closed yet\n    libc::close(fd)\n}",
        "unsafe {\n// SAFETY: caller guarantees fd is valid and owned by this function for closure\n    libc::close(fd)\n}"
      ],
      "invalid_outputs": [
        "unsafe { libc::close(fd) }",
        "unsafe {\n    // Just a regular comment\n    libc::close(fd)\n}",
        "unsafe {\n// TODO: add safety comment\n    libc::close(fd)\n}"
      ],
      "tags": [
        "semantics",
        "unsafe",
        "documentation",
        "safety"
      ],
      "language": "rust",
      "domain": "semantics"
    },
    {
      "id": "rust-syntax-001",
      "name": "Serde Struct Schema for Configuration",
      "description": "Constraint generation for serde-compatible struct definitions",
      "scenario": "Developer creating a configuration struct that must serialize/deserialize with serde. The struct needs derive macros, field attributes for rename/default, and specific types. The constraint ensures generated struct follows serde conventions.",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n            \"type\": \"object\",\n            \"properties\": {\n                \"host\": {\"type\": \"string\"},\n                \"port\": {\"type\": \"integer\"},\n                \"ssl_enabled\": {\"type\": \"boolean\"},\n                \"timeout_ms\": {\"type\": \"integer\"}\n            },\n            \"required\": [\"host\", \"port\"]\n        }",
        "language": "rust",
        "imports": [
          {
            "module": "serde",
            "name": "Serialize"
          },
          {
            "module": "serde",
            "name": "Deserialize"
          }
        ]
      },
      "expected_effect": "Masks tokens producing structs without serde derives or incompatible types. Ensures #[derive(Serialize, Deserialize)] is present and fields match schema.",
      "valid_outputs": [
        "#[derive(Serialize, Deserialize)]\nstruct Config {\n    host: String,\n    port: u16,\n    #[serde(default)]\n    ssl_enabled: bool,\n    #[serde(default = \"default_timeout\")]\n    timeout_ms: u64,\n}",
        "#[derive(Serialize, Deserialize, Debug)]\n#[serde(rename_all = \"camelCase\")]\nstruct Config {\n    host: String,\n    port: u16,\n    ssl_enabled: bool,\n    timeout_ms: u64,\n}"
      ],
      "invalid_outputs": [
        "struct Config {\n    host: String,\n    port: u16,\n}",
        "#[derive(Debug)]\nstruct Config {\n    host: String,\n    port: u16,\n}",
        "#[derive(Serialize, Deserialize)]\nstruct Config {\n    host: &str,\n    port: u16,\n}"
      ],
      "tags": [
        "syntax",
        "serde",
        "struct",
        "schema"
      ],
      "language": "rust",
      "domain": "syntax"
    },
    {
      "id": "rust-syntax-002",
      "name": "Semantic Version Regex Pattern",
      "description": "Constraint generation for semver version string validation",
      "scenario": "Developer implementing version parsing for Cargo.toml dependencies. Version strings must match semver 2.0.0 spec: MAJOR.MINOR.PATCH with optional pre/build. The constraint ensures generated regex correctly validates semver format.",
      "spec": {
        "version": "1.0",
        "regex": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$",
        "language": "rust",
        "type_bindings": [
          {
            "name": "version_str",
            "type_expr": "&str",
            "scope": "parameter"
          }
        ]
      },
      "expected_effect": "Masks tokens producing non-semver version patterns. Ensures regex matches MAJOR.MINOR.PATCH with optional -prerelease and +build metadata.",
      "valid_outputs": [
        "\"1.0.0\"",
        "\"2.1.3-alpha.1\"",
        "\"0.0.1-beta+build.123\"",
        "\"10.20.30-rc.1+20230101\""
      ],
      "invalid_outputs": [
        "\"1.0\"",
        "\"v1.0.0\"",
        "\"1.0.0.0\"",
        "\"01.0.0\""
      ],
      "tags": [
        "syntax",
        "regex",
        "semver",
        "validation"
      ],
      "language": "rust",
      "domain": "syntax"
    },
    {
      "id": "rust-syntax-003",
      "name": "Macro DSL Pattern for Builder",
      "description": "Constraint generation for declarative macro builder pattern",
      "scenario": "Developer creating a builder macro that generates struct builder code. The macro takes field definitions and produces a fluent builder API. The constraint ensures generated macro follows Rust macro_rules! syntax.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"macro_rules! \" name \" {\" ws rules ws \"}\"\n        name ::= [a-z_]+\n        rules ::= rule (ws \";\" ws rule)*\n        rule ::= \"(\" pattern \")\" \" => \" \"{\" expansion \"}\"\n        pattern ::= \"{ \" fields \" }\"\n        fields ::= field (\" , \" field)*\n        field ::= \"$\" var \":ident : \" \"$\" type \":ty\"\n        var ::= [a-z]+\n        type ::= [a-z]+\n        expansion ::= \"pub struct Builder { \" builder-fields \" }\"\n        builder-fields ::= builder-field (\" , \" builder-field)*\n        builder-field ::= \"$\" var \": Option<\" \"$\" type \">\"\n        ws ::= \" \" | \"\\n\"\n        ",
        "language": "rust"
      },
      "expected_effect": "Masks tokens that don't follow macro_rules! syntax. Ensures proper capture of :ident and :ty fragments with $ prefix and correct expansion.",
      "valid_outputs": [
        "macro_rules! build_struct {\n    ({ $name:ident : $ty:ty }) => {\n        pub struct Builder { $name: Option<$ty> }\n    };\n}",
        "macro_rules! builder {\n    ({ $field1:ident : $type1:ty , $field2:ident : $type2:ty }) => {\n        pub struct Builder { $field1: Option<$type1> , $field2: Option<$type2> }\n    };\n}"
      ],
      "invalid_outputs": [
        "macro_rules! build_struct {\n    (name: ty) => {\n        pub struct Builder { name: Option<ty> }\n    };\n}",
        "macro_rules! build_struct {\n    ({ $name }) => {\n        pub struct Builder { $name }\n    };\n}",
        "fn build_struct() {\n    pub struct Builder { name: Option<String> }\n}"
      ],
      "tags": [
        "syntax",
        "macro",
        "dsl",
        "builder"
      ],
      "language": "rust",
      "domain": "syntax"
    },
    {
      "id": "rust-ownership-001",
      "name": "Pin<Box<T>> for Self-Referential Structs",
      "description": "Constraint generation for pinned heap allocations with self-references",
      "scenario": "Developer implementing an async Future with internal references. The struct contains a pointer to its own data, requiring Pin to prevent moves. The constraint ensures proper Pin::new_unchecked usage with safety invariants.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"let mut \" var \" = Box::new(\" struct-init \");\" ws\n                 \"let \" ptr-init ws\n                 \"let \" var \"_pinned = unsafe {\" ws safety-comment ws pin-expr ws \"};\"\n        var ::= [a-z_]+\n        struct-init ::= \"SelfRef { data: \" expr \", ptr: std::ptr::null()\" \", _pin: PhantomPinned }\"\n        expr ::= \"data\"\n        ptr-init ::= \"ptr = &\" var \".data as *const String;\"\n        safety-comment ::= \"// SAFETY:\" [^\\n]+\n        pin-expr ::= \"Pin::new_unchecked(\" var \")\"\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "data",
            "type_expr": "String",
            "scope": "local",
            "mutable": false
          }
        ],
        "imports": [
          {
            "module": "std::pin",
            "name": "Pin"
          },
          {
            "module": "std::marker",
            "name": "PhantomPinned"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "self_reference_valid_after_pin()",
            "scope": "new"
          },
          {
            "kind": "invariant",
            "expression": "unsafe_block_has_safety_doc()",
            "scope": "new"
          }
        ]
      },
      "expected_effect": "Masks tokens that create self-references without Pin or violate pinning guarantees. Ensures struct is heap-allocated, pointer established, then pinned with unsafe and SAFETY doc.",
      "valid_outputs": [
        "let mut selfish = Box::new(SelfRef { data: data, ptr: std::ptr::null(), _pin: PhantomPinned });\nlet ptr = &selfish.data as *const String;\nlet selfish_pinned = unsafe {\n// SAFETY: selfish is heap-allocated and will not be moved after pinning\n    Pin::new_unchecked(selfish)\n};"
      ],
      "invalid_outputs": [
        "let selfish = SelfRef { data, ptr: &data, _pin: PhantomPinned };",
        "let selfish = Box::new(SelfRef { data, ptr: &data, _pin: PhantomPinned });",
        "let selfish_pinned = unsafe { Pin::new_unchecked(Box::new(SelfRef { data, ptr: std::ptr::null(), _pin: PhantomPinned })) };"
      ],
      "tags": [
        "ownership",
        "pin",
        "self-referential",
        "unsafe"
      ],
      "language": "rust",
      "domain": "types"
    },
    {
      "id": "rust-ownership-002",
      "name": "Lifetime Inference with 'static Bounds",
      "description": "Constraint generation for functions requiring 'static lifetime on generic types",
      "scenario": "Developer implementing a spawn_task function that sends data to another thread. The generic type T must be 'static (no borrowed data) to safely move across threads. The constraint ensures generated function signature has 'static bound.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"fn spawn_task<T: \" bounds \">(task: T) -> \" return-type \" {\" ws body ws \"}\"\n        bounds ::= \"'static + Send + \" trait\n        trait ::= \"FnOnce()\" | \"Fn()\"\n        return-type ::= \"thread::JoinHandle<()>\"\n        body ::= \"thread::spawn(move || task())\"\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "task",
            "type_expr": "T",
            "scope": "parameter",
            "mutable": false
          }
        ],
        "imports": [
          {
            "module": "std::thread"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "T: 'static + Send",
            "scope": "spawn_task",
            "variables": [
              "T"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens producing function signatures without 'static bound. Ensures T cannot contain borrowed data that would become invalid when moved to spawned thread.",
      "valid_outputs": [
        "fn spawn_task<T: 'static + Send + FnOnce()>(task: T) -> thread::JoinHandle<()> {\n    thread::spawn(move || task())\n}",
        "fn spawn_task<T: 'static + Send + Fn()>(task: T) -> thread::JoinHandle<()> {\n    thread::spawn(move || task())\n}"
      ],
      "invalid_outputs": [
        "fn spawn_task<T: Send + FnOnce()>(task: T) -> thread::JoinHandle<()> {\n    thread::spawn(move || task())\n}",
        "fn spawn_task<T: FnOnce()>(task: T) -> thread::JoinHandle<()> {\n    thread::spawn(move || task())\n}",
        "fn spawn_task<T>(task: T) -> thread::JoinHandle<()> {\n    thread::spawn(move || task())\n}"
      ],
      "tags": [
        "ownership",
        "lifetimes",
        "static",
        "threading"
      ],
      "language": "rust",
      "domain": "types"
    },
    {
      "id": "rust-ownership-003",
      "name": "Arc<Mutex<T>> Shared Mutable State",
      "description": "Constraint generation for thread-safe shared mutable state pattern",
      "scenario": "Developer implementing a shared counter accessed by multiple threads. Arc provides shared ownership, Mutex enables interior mutability. The constraint ensures proper clone for Arc and lock/unwrap for access.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= setup ws threads ws joins\n        setup ::= \"let counter = Arc::new(Mutex::new(0));\"\n        threads ::= thread (ws thread)*\n        thread ::= \"let counter\" digit \" = Arc::clone(&counter);\" ws\n                   \"let handle\" digit \" = thread::spawn(move || {\" ws increment ws \"});\"\n        digit ::= [0-9]\n        increment ::= \"let mut num = counter\" digit \".lock().unwrap();\" ws \"*num += 1;\"\n        joins ::= \"handle\" digit \".join().unwrap();\" (ws \"handle\" digit \".join().unwrap();\")*\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "counter",
            "type_expr": "Arc<Mutex<i32>>",
            "scope": "local",
            "mutable": false
          }
        ],
        "imports": [
          {
            "module": "std::sync",
            "name": "Arc"
          },
          {
            "module": "std::sync",
            "name": "Mutex"
          },
          {
            "module": "std::thread"
          }
        ],
        "control_flow": {
          "function_name": "increment_counter"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "no_deadlocks_possible()",
            "scope": "increment_counter"
          }
        ]
      },
      "expected_effect": "Masks tokens that access Arc without clone or Mutex without lock. Ensures Arc::clone creates new reference counts and lock() is called before mutation.",
      "valid_outputs": [
        "let counter = Arc::new(Mutex::new(0));\nlet counter1 = Arc::clone(&counter);\nlet handle1 = thread::spawn(move || {\n    let mut num = counter1.lock().unwrap();\n    *num += 1;\n});\nlet counter2 = Arc::clone(&counter);\nlet handle2 = thread::spawn(move || {\n    let mut num = counter2.lock().unwrap();\n    *num += 1;\n});\nhandle1.join().unwrap();\nhandle2.join().unwrap();"
      ],
      "invalid_outputs": [
        "let counter = Mutex::new(0);\nthread::spawn(move || { counter.lock().unwrap(); });",
        "let counter = Arc::new(Mutex::new(0));\nthread::spawn(move || { *counter += 1; });",
        "let counter = Arc::new(Mutex::new(0));\nlet handle = thread::spawn(|| { counter.lock().unwrap(); });"
      ],
      "tags": [
        "ownership",
        "arc",
        "mutex",
        "concurrency"
      ],
      "language": "rust",
      "domain": "types"
    },
    {
      "id": "rust-ownership-004",
      "name": "Lifetime Elision and Explicit Annotations",
      "description": "Constraint generation demonstrating when explicit lifetime annotations are required",
      "scenario": "Developer writing a function returning the longer of two string slices. Rust's lifetime elision rules don't apply when multiple input lifetimes exist. The constraint ensures explicit lifetime 'a is present to tie inputs to output.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\" ws body ws \"}\"\n        body ::= \"if x.len() > y.len() { x } else { y }\"\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "x",
            "type_expr": "&'a str",
            "scope": "parameter"
          },
          {
            "name": "y",
            "type_expr": "&'a str",
            "scope": "parameter"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "output_lifetime <= min(x.lifetime, y.lifetime)",
            "scope": "longest",
            "variables": [
              "x",
              "y"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens producing function signatures without lifetime parameters. Ensures 'a is declared and consistently used on both inputs and output.",
      "valid_outputs": [
        "fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}",
        "fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() >= y.len() { x } else { y }\n}"
      ],
      "invalid_outputs": [
        "fn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() { x } else { y }\n}",
        "fn longest<'a>(x: &'a str, y: &str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}",
        "fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}"
      ],
      "tags": [
        "ownership",
        "lifetimes",
        "elision",
        "borrowing"
      ],
      "language": "rust",
      "domain": "types"
    },
    {
      "id": "rust-ownership-005",
      "name": "Interior Mutability with RefCell",
      "description": "Constraint generation for runtime borrow checking with RefCell",
      "scenario": "Developer implementing a graph node with internal caching that mutates through shared refs. RefCell allows mutation through &self by deferring borrow checks to runtime. The constraint ensures borrow_mut() is used correctly and panics are documented.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"if \" check \" {\" ws return-cached ws \"}\" ws compute ws update ws return-new\n        check ::= \"let cached = self.cache.borrow(); cached.is_some()\"\n        return-cached ::= \"return cached.as_ref().unwrap().clone();\"\n        compute ::= \"let value = self.compute_expensive();\"\n        update ::= \"*self.cache.borrow_mut() = Some(value.clone());\"\n        return-new ::= \"value\"\n        ws ::= \"\\n\"\n        ",
        "language": "rust",
        "type_bindings": [
          {
            "name": "cache",
            "type_expr": "RefCell<Option<Value>>",
            "scope": "class:Node"
          }
        ],
        "imports": [
          {
            "module": "std::cell",
            "name": "RefCell"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "no_overlapping_borrows()",
            "scope": "get_cached"
          }
        ]
      },
      "expected_effect": "Masks tokens that hold borrow() while calling borrow_mut(), causing runtime panic. Ensures borrows are dropped (scoped) before mutation via borrow_mut().",
      "valid_outputs": [
        "if let cached = self.cache.borrow(); cached.is_some() {\n    return cached.as_ref().unwrap().clone();\n}\nlet value = self.compute_expensive();\n*self.cache.borrow_mut() = Some(value.clone());\nvalue"
      ],
      "invalid_outputs": [
        "let cached = self.cache.borrow();\nif cached.is_some() {\n    return cached.as_ref().unwrap().clone();\n}\n*self.cache.borrow_mut() = Some(value);",
        "self.cache.borrow_mut().get_or_insert_with(|| self.compute_expensive())"
      ],
      "tags": [
        "ownership",
        "interior-mutability",
        "refcell",
        "borrowing"
      ],
      "language": "rust",
      "domain": "types"
    },
    {
      "id": "zig-types-001",
      "name": "Comptime Type Selection",
      "description": "Generic function using @TypeOf and comptime type parameters",
      "scenario": "Developer writing a generic swap function that preserves exact types",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "comptime type",
            "scope": "parameter",
            "mutable": false
          },
          {
            "name": "a",
            "type_expr": "*T",
            "scope": "parameter"
          },
          {
            "name": "b",
            "type_expr": "*T",
            "scope": "parameter"
          }
        ],
        "expected_type": "fn(comptime T: type, a: *T, b: *T) void",
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "@TypeOf(a.*) == @TypeOf(b.*)",
            "scope": "swap",
            "variables": [
              "a",
              "b"
            ]
          }
        ],
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks tokens that don't maintain comptime type parameter T; ensures pointer dereference matches generic type",
      "valid_outputs": [
        "fn swap(comptime T: type, a: *T, b: *T) void {\n    const tmp: T = a.*;\n    a.* = b.*;\n    b.* = tmp;\n}",
        "pub fn swap(comptime T: type, a: *T, b: *T) void {\n    const temp = a.*;\n    a.* = b.*;\n    b.* = temp;\n}"
      ],
      "invalid_outputs": [
        "fn swap(a: *anyopaque, b: *anyopaque) void { ... }",
        "fn swap(comptime T: type, a: T, b: T) void { ... }",
        "fn swap(comptime T: type, a: *T, b: *T) void { a = b; }"
      ],
      "tags": [
        "types",
        "comptime",
        "generics",
        "pointers"
      ],
      "language": "zig",
      "domain": "types"
    },
    {
      "id": "zig-types-002",
      "name": "Error Union Unwrap",
      "description": "Function returning error union with explicit error handling",
      "scenario": "Developer parsing an integer from a string with proper error handling",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "function_signatures": [
          {
            "name": "parseInt",
            "params": [
              {
                "name": "input",
                "type_expr": "[]const u8",
                "scope": "parameter"
              }
            ],
            "return_type": "!i32"
          }
        ],
        "expected_type": "!i32",
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "result >= std.math.minInt(i32) and result <= std.math.maxInt(i32)",
            "scope": "parseInt",
            "variables": [
              "result"
            ]
          }
        ],
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks tokens producing non-error-union types; requires explicit error handling syntax",
      "valid_outputs": [
        "fn parseInt(input: []const u8) !i32 {\n    return std.fmt.parseInt(i32, input, 10);\n}",
        "fn parseInt(input: []const u8) !i32 {\n    const result = std.fmt.parseInt(i32, input, 10) catch return error.InvalidFormat;\n    return result;\n}",
        "fn parseInt(input: []const u8) !i32 {\n    if (input.len == 0) return error.EmptyInput;\n    return try std.fmt.parseInt(i32, input, 10);\n}"
      ],
      "invalid_outputs": [
        "fn parseInt(input: []const u8) i32 { ... }",
        "fn parseInt(input: []const u8) !i32 { return 42; }",
        "fn parseInt(input: []const u8) error{InvalidFormat}!i32 { ... }"
      ],
      "tags": [
        "types",
        "error-union",
        "error-handling"
      ],
      "language": "zig",
      "domain": "types"
    },
    {
      "id": "zig-types-003",
      "name": "Sentinel-Terminated Array",
      "description": "Function working with null-terminated C strings using [*:0]u8",
      "scenario": "Developer writing FFI wrapper for C library expecting null-terminated strings",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "str",
            "type_expr": "[*:0]const u8",
            "scope": "parameter",
            "mutable": false
          }
        ],
        "function_signatures": [
          {
            "name": "strlen",
            "params": [
              {
                "name": "str",
                "type_expr": "[*:0]const u8",
                "scope": "parameter",
                "mutable": false
              }
            ],
            "return_type": "usize"
          }
        ],
        "expected_type": "usize",
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "str[result] == 0",
            "scope": "strlen",
            "variables": [
              "str",
              "result"
            ]
          }
        ],
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks tokens not handling sentinel-terminated pointers; ensures null terminator awareness",
      "valid_outputs": [
        "fn strlen(str: [*:0]const u8) usize {\n    var len: usize = 0;\n    while (str[len] != 0) : (len += 1) {}\n    return len;\n}",
        "pub fn strlen(str: [*:0]const u8) usize {\n    var i: usize = 0;\n    while (str[i] != 0) { i += 1; }\n    return i;\n}",
        "fn strlen(str: [*:0]const u8) usize {\n    return std.mem.len(str);\n}"
      ],
      "invalid_outputs": [
        "fn strlen(str: []const u8) usize { ... }",
        "fn strlen(str: [*]const u8) usize { ... }",
        "fn strlen(str: [*:0]const u8) usize { return str.len; }"
      ],
      "tags": [
        "types",
        "sentinel",
        "c-interop",
        "pointers"
      ],
      "language": "zig",
      "domain": "types"
    },
    {
      "id": "zig-imports-001",
      "name": "WASM Target std.os Restriction",
      "description": "Prevent use of std.os when targeting WebAssembly",
      "scenario": "Developer writing cross-platform code that must work in WASM environment",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "imports": [
          {
            "module": "std"
          },
          {
            "module": "std.mem"
          },
          {
            "module": "std.debug"
          }
        ],
        "available_modules": [
          "std",
          "std.ArrayList",
          "std.HashMap",
          "std.debug",
          "std.math",
          "std.mem"
        ],
        "forbidden_imports": [
          "std.fs",
          "std.net",
          "std.os"
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "!@hasDecl(@import(\"std\"), \"os\")",
            "scope": "module"
          }
        ],
        "domain_configs": {
          "import": {
            "target": "wasm32-freestanding",
            "strict_platform_check": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks tokens importing or using std.os, std.fs, std.net; allows only WASM-compatible std modules",
      "valid_outputs": [
        "const std = @import(\"std\");\nconst mem = std.mem;\n\npub fn process(data: []const u8) void {\n    const copy = mem.dupe(std.heap.page_allocator, u8, data) catch unreachable;\n    defer std.heap.page_allocator.free(copy);\n}",
        "const std = @import(\"std\");\nconst ArrayList = std.ArrayList;\n\npub fn buildList(allocator: std.mem.Allocator) !ArrayList(u32) {\n    var list = ArrayList(u32).init(allocator);\n    try list.append(42);\n    return list;\n}"
      ],
      "invalid_outputs": [
        "const std = @import(\"std\");\nconst os = std.os;\n...",
        "const fs = @import(\"std\").fs;\npub fn readFile(path: []const u8) ![]u8 { ... }",
        "const net = @import(\"std\").net;"
      ],
      "tags": [
        "imports",
        "platform",
        "wasm",
        "constraints"
      ],
      "language": "zig",
      "domain": "imports"
    },
    {
      "id": "zig-imports-002",
      "name": "Build-time Feature Flags",
      "description": "Use @import(\"build_options\") for compile-time configuration",
      "scenario": "Developer using build-time feature flags to enable/disable functionality",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "build_options",
            "type_expr": "type",
            "scope": "module",
            "mutable": false
          },
          {
            "name": "enable_logging",
            "type_expr": "bool",
            "scope": "module",
            "mutable": false
          }
        ],
        "imports": [
          {
            "module": "std"
          },
          {
            "module": "build_options"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "assertion",
            "expression": "@typeInfo(@TypeOf(build_options.enable_logging)) == .Bool",
            "scope": "module",
            "variables": [
              "build_options"
            ]
          }
        ],
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks tokens not using build_options correctly; requires comptime feature flag checks",
      "valid_outputs": [
        "const build_options = @import(\"build_options\");\nconst std = @import(\"std\");\n\npub fn log(msg: []const u8) void {\n    if (build_options.enable_logging) {\n        std.debug.print(\"{s}\\n\", .{msg});\n    }\n}",
        "const options = @import(\"build_options\");\n\npub fn process() void {\n    if (comptime options.enable_debug) {\n        @compileLog(\"Debug mode enabled\");\n    }\n}",
        "const build_options = @import(\"build_options\");\nconst Feature = enum { basic, advanced };\n\npub fn getFeatureLevel() Feature {\n    return if (build_options.advanced_features) .advanced else .basic;\n}"
      ],
      "invalid_outputs": [
        "const build_options = @import(\"build_options\");\nvar enable_logging = true;\n...",
        "pub fn log(msg: []const u8) void {\n    if (std.os.getenv(\"ENABLE_LOGGING\")) { ... }\n}",
        "const opts = @import(\"build_options\");\npub fn process() void { opts.enable_logging = false; }"
      ],
      "tags": [
        "imports",
        "comptime",
        "build-options",
        "feature-flags"
      ],
      "language": "zig",
      "domain": "imports"
    },
    {
      "id": "zig-imports-003",
      "name": "Explicit Allocator Requirement",
      "description": "Functions must accept allocator parameter, not use global allocators",
      "scenario": "Developer writing library code that requires explicit allocator passing",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "allocator",
            "type_expr": "std.mem.Allocator",
            "scope": "parameter",
            "mutable": false
          }
        ],
        "imports": [
          {
            "module": "std"
          },
          {
            "module": "std.mem",
            "name": "Allocator"
          }
        ],
        "forbidden_imports": [
          "std.heap.c_allocator",
          "std.heap.page_allocator"
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "@TypeOf(allocator) == std.mem.Allocator",
            "scope": "function",
            "variables": [
              "allocator"
            ]
          }
        ],
        "domain_configs": {
          "semantic": {
            "forbid_globals": [
              "std.heap.page_allocator",
              "std.heap.c_allocator"
            ],
            "require_explicit_allocator": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks tokens using global allocators; requires allocator parameter in function signatures",
      "valid_outputs": [
        "const std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\npub fn createBuffer(allocator: Allocator, size: usize) ![]u8 {\n    return try allocator.alloc(u8, size);\n}",
        "pub fn duplicate(allocator: std.mem.Allocator, data: []const u8) ![]u8 {\n    const copy = try allocator.alloc(u8, data.len);\n    @memcpy(copy, data);\n    return copy;\n}",
        "const std = @import(\"std\");\n\npub fn processData(allocator: std.mem.Allocator, items: []const u32) !std.ArrayList(u32) {\n    var list = std.ArrayList(u32).init(allocator);\n    for (items) |item| { try list.append(item * 2); }\n    return list;\n}"
      ],
      "invalid_outputs": [
        "pub fn createBuffer(size: usize) ![]u8 {\n    return try std.heap.page_allocator.alloc(u8, size);\n}",
        "pub fn duplicate(data: []const u8) ![]u8 {\n    const allocator = std.heap.c_allocator;\n    return try allocator.alloc(u8, data.len);\n}",
        "var gpa = std.heap.GeneralPurposeAllocator(.{}){};\npub fn createBuffer(size: usize) ![]u8 {\n    return try gpa.allocator().alloc(u8, size);\n}"
      ],
      "tags": [
        "imports",
        "allocator",
        "memory-management",
        "best-practices"
      ],
      "language": "zig",
      "domain": "imports"
    },
    {
      "id": "zig-controlflow-001",
      "name": "Error Defer Cleanup",
      "description": "Resource cleanup using errdefer for error paths",
      "scenario": "Developer acquiring resources that must be cleaned up on error",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "function_signatures": [
          {
            "name": "createResource",
            "params": [
              {
                "name": "allocator",
                "type_expr": "std.mem.Allocator",
                "scope": "parameter"
              }
            ],
            "return_type": "!*Resource"
          }
        ],
        "control_flow": {
          "function_name": "createResource",
          "in_try_block": true,
          "exception_types": [
            "OutOfMemory",
            "InvalidResource"
          ]
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "on_error_path implies resource_freed",
            "scope": "createResource",
            "variables": [
              "resource"
            ]
          }
        ],
        "domain_configs": {
          "controlflow": {
            "require_errdefer": true,
            "track_resource_lifetime": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks control flow tokens that don't include errdefer cleanup; enforces error-path resource management",
      "valid_outputs": [
        "pub fn createResource(allocator: std.mem.Allocator) !*Resource {\n    const resource = try allocator.create(Resource);\n    errdefer allocator.destroy(resource);\n    try resource.init();\n    return resource;\n}",
        "pub fn createResource(allocator: std.mem.Allocator) !*Resource {\n    const resource = try allocator.create(Resource);\n    errdefer allocator.destroy(resource);\n    resource.* = Resource{};\n    try resource.connect();\n    errdefer resource.disconnect();\n    return resource;\n}",
        "fn createResource(allocator: std.mem.Allocator) !*Resource {\n    var resource = try allocator.create(Resource);\n    errdefer allocator.destroy(resource);\n    resource.state = try initState(allocator);\n    errdefer resource.state.deinit();\n    return resource;\n}"
      ],
      "invalid_outputs": [
        "pub fn createResource(allocator: std.mem.Allocator) !*Resource {\n    const resource = try allocator.create(Resource);\n    try resource.init();\n    return resource;\n}",
        "pub fn createResource(allocator: std.mem.Allocator) !*Resource {\n    const resource = try allocator.create(Resource);\n    defer allocator.destroy(resource);\n    try resource.init();\n    return resource;\n}",
        "pub fn createResource(allocator: std.mem.Allocator) !*Resource {\n    const resource = allocator.create(Resource) catch |err| { return err; };\n    try resource.init();\n    return resource;\n}"
      ],
      "tags": [
        "controlflow",
        "errdefer",
        "resource-management",
        "error-handling"
      ],
      "language": "zig",
      "domain": "controlflow"
    },
    {
      "id": "zig-controlflow-002",
      "name": "Comptime Branches",
      "description": "Compile-time conditional logic using comptime if",
      "scenario": "Developer writing code that branches at compile time based on type properties",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "comptime type",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "printValue",
            "params": [
              {
                "name": "comptime_T",
                "type_expr": "type",
                "scope": "parameter"
              },
              {
                "name": "value",
                "type_expr": "T",
                "scope": "parameter"
              }
            ],
            "return_type": "void"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "assertion",
            "expression": "@typeInfo(T) != .Undefined",
            "scope": "printValue",
            "variables": [
              "T"
            ]
          }
        ],
        "domain_configs": {
          "controlflow": {
            "require_comptime_evaluation": true,
            "check_type_properties": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks runtime branches where comptime branches required; ensures compile-time type introspection",
      "valid_outputs": [
        "pub fn printValue(comptime T: type, value: T) void {\n    if (comptime @typeInfo(T) == .Int) {\n        std.debug.print(\"Integer: {}\\n\", .{value});\n    } else if (comptime @typeInfo(T) == .Float) {\n        std.debug.print(\"Float: {d}\\n\", .{value});\n    } else {\n        @compileError(\"Unsupported type\");\n    }\n}",
        "pub fn printValue(comptime T: type, value: T) void {\n    const info = @typeInfo(T);\n    if (comptime info == .Struct) {\n        @compileLog(\"Printing struct\", T);\n    }\n    std.debug.print(\"{any}\\n\", .{value});\n}",
        "fn printValue(comptime T: type, value: T) void {\n    comptime {\n        const ti = @typeInfo(T);\n        if (ti != .Int and ti != .Float) {\n            @compileError(\"Only numeric types supported\");\n        }\n    }\n    std.debug.print(\"{}\\n\", .{value});\n}"
      ],
      "invalid_outputs": [
        "pub fn printValue(comptime T: type, value: T) void {\n    if (@typeInfo(T) == .Int) { ... }\n}",
        "pub fn printValue(comptime T: type, value: T) void {\n    const is_int = @typeInfo(T) == .Int;\n    if (is_int) { ... }\n}",
        "pub fn printValue(T: type, value: T) void { ... }"
      ],
      "tags": [
        "controlflow",
        "comptime",
        "type-introspection",
        "metaprogramming"
      ],
      "language": "zig",
      "domain": "controlflow"
    },
    {
      "id": "zig-controlflow-003",
      "name": "Unreachable Assertions",
      "description": "Exhaustive switch with unreachable for safety guarantees",
      "scenario": "Developer handling all enum cases with unreachable for impossible states",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "state",
            "type_expr": "enum { idle, running, stopped }",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "handleState"
        },
        "semantic_constraints": [
          {
            "kind": "assertion",
            "expression": "switch_exhaustive(state)",
            "scope": "handleState",
            "variables": [
              "state"
            ]
          }
        ],
        "domain_configs": {
          "controlflow": {
            "require_exhaustive_switch": true,
            "enforce_unreachable": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks non-exhaustive switches; requires unreachable for provably impossible paths",
      "valid_outputs": [
        "const State = enum { idle, running, stopped };\n\npub fn handleState(state: State) void {\n    switch (state) {\n        .idle => std.debug.print(\"Idle\\n\", .{}),\n        .running => std.debug.print(\"Running\\n\", .{}),\n        .stopped => std.debug.print(\"Stopped\\n\", .{}),\n    }\n}",
        "fn handleState(state: State) u32 {\n    return switch (state) {\n        .idle => 0,\n        .running => 1,\n        .stopped => 2,\n    };\n}",
        "pub fn handleState(state: State) void {\n    switch (state) {\n        .idle, .stopped => { /* handle both */ },\n        .running => { /* handle running */ },\n    }\n}"
      ],
      "invalid_outputs": [
        "pub fn handleState(state: State) void {\n    switch (state) {\n        .idle => {},\n        .running => {},\n        else => unreachable,\n    }\n}",
        "pub fn handleState(state: State) void {\n    if (state == .idle) { ... }\n    else if (state == .running) { ... }\n}",
        "pub fn handleState(state: State) void {\n    switch (state) {\n        .idle => {},\n        _ => {},\n    }\n}"
      ],
      "tags": [
        "controlflow",
        "unreachable",
        "exhaustiveness",
        "switch",
        "safety"
      ],
      "language": "zig",
      "domain": "controlflow"
    },
    {
      "id": "zig-semantics-001",
      "name": "Allocation Safety",
      "description": "Every allocation must have corresponding free or transfer ownership",
      "scenario": "Developer writing function that allocates memory and must ensure cleanup",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "function_signatures": [
          {
            "name": "processData",
            "params": [
              {
                "name": "allocator",
                "type_expr": "std.mem.Allocator",
                "scope": "parameter"
              },
              {
                "name": "input",
                "type_expr": "[]const u8",
                "scope": "parameter"
              }
            ],
            "return_type": "void"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "forall buffer: allocated_in_scope -> freed_in_scope or returned",
            "scope": "processData",
            "variables": [
              "allocator",
              "buffer"
            ]
          },
          {
            "kind": "invariant",
            "expression": "alloc_count == free_count or ownership_transferred",
            "scope": "processData",
            "variables": [
              "allocator"
            ]
          }
        ],
        "domain_configs": {
          "semantic": {
            "track_allocations": true,
            "require_paired_alloc_free": true,
            "allow_ownership_transfer": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks code paths with unpaired allocations; requires defer or errdefer for cleanup",
      "valid_outputs": [
        "pub fn processData(allocator: std.mem.Allocator, input: []const u8) void {\n    const buffer = allocator.alloc(u8, input.len) catch return;\n    defer allocator.free(buffer);\n    @memcpy(buffer, input);\n    // process buffer\n}",
        "pub fn processData(allocator: std.mem.Allocator, input: []const u8) void {\n    const buffer = allocator.alloc(u8, 1024) catch return;\n    defer allocator.free(buffer);\n    const copied = @min(buffer.len, input.len);\n    @memcpy(buffer[0..copied], input[0..copied]);\n}",
        "pub fn processData(allocator: std.mem.Allocator, input: []const u8) void {\n    var buffer = allocator.alloc(u8, input.len) catch return;\n    errdefer allocator.free(buffer);\n    @memcpy(buffer, input);\n    process(buffer);\n    allocator.free(buffer);\n}"
      ],
      "invalid_outputs": [
        "pub fn processData(allocator: std.mem.Allocator, input: []const u8) void {\n    const buffer = allocator.alloc(u8, input.len) catch return;\n    @memcpy(buffer, input);\n}",
        "pub fn processData(allocator: std.mem.Allocator, input: []const u8) void {\n    const buffer = allocator.alloc(u8, input.len) catch return;\n    if (input.len > 0) {\n        allocator.free(buffer);\n    }\n}",
        "pub fn processData(allocator: std.mem.Allocator, input: []const u8) void {\n    var buffer = allocator.alloc(u8, 1024) catch return;\n    if (shouldProcess(input)) {\n        defer allocator.free(buffer);\n    }\n}"
      ],
      "tags": [
        "semantics",
        "memory-safety",
        "allocation",
        "resource-management"
      ],
      "language": "zig",
      "domain": "semantics"
    },
    {
      "id": "zig-semantics-002",
      "name": "Memory Leak Prevention",
      "description": "Detect and prevent memory leaks through ownership tracking",
      "scenario": "Developer creating data structure that owns allocated memory",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "Container",
            "type_expr": "struct { allocator: std.mem.Allocator, data: []u8 }",
            "scope": "module"
          }
        ],
        "function_signatures": [
          {
            "name": "init",
            "params": [
              {
                "name": "allocator",
                "type_expr": "std.mem.Allocator",
                "scope": "parameter"
              }
            ],
            "return_type": "!Container"
          },
          {
            "name": "deinit",
            "params": [
              {
                "name": "self",
                "type_expr": "*Container",
                "scope": "parameter"
              }
            ],
            "return_type": "void"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "exists deinit method for every struct with owned allocations",
            "scope": "Container",
            "variables": [
              "Container"
            ]
          },
          {
            "kind": "postcondition",
            "expression": "after deinit: all owned memory freed",
            "scope": "Container.deinit",
            "variables": [
              "self"
            ]
          }
        ],
        "domain_configs": {
          "semantic": {
            "require_deinit_for_owned_memory": true,
            "track_struct_ownership": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks struct definitions lacking deinit when owning memory; enforces cleanup method pattern",
      "valid_outputs": [
        "const Container = struct {\n    allocator: std.mem.Allocator,\n    data: []u8,\n\n    pub fn init(allocator: std.mem.Allocator) !Container {\n        const data = try allocator.alloc(u8, 256);\n        return Container{ .allocator = allocator, .data = data };\n    }\n\n    pub fn deinit(self: *Container) void {\n        self.allocator.free(self.data);\n    }\n};",
        "const Container = struct {\n    allocator: std.mem.Allocator,\n    data: []u8,\n    extra: []u32,\n\n    pub fn init(allocator: std.mem.Allocator) !Container {\n        const data = try allocator.alloc(u8, 256);\n        errdefer allocator.free(data);\n        const extra = try allocator.alloc(u32, 64);\n        return Container{ .allocator = allocator, .data = data, .extra = extra };\n    }\n\n    pub fn deinit(self: *Container) void {\n        self.allocator.free(self.data);\n        self.allocator.free(self.extra);\n    }\n};"
      ],
      "invalid_outputs": [
        "const Container = struct {\n    allocator: std.mem.Allocator,\n    data: []u8,\n\n    pub fn init(allocator: std.mem.Allocator) !Container {\n        const data = try allocator.alloc(u8, 256);\n        return Container{ .allocator = allocator, .data = data };\n    }\n};",
        "const Container = struct {\n    allocator: std.mem.Allocator,\n    data: []u8,\n\n    pub fn deinit(self: *Container) void {\n        // Empty deinit doesn't free data\n    }\n};",
        "const Container = struct {\n    data: []u8,\n\n    pub fn deinit(self: *Container) void {\n        // Can't free without allocator reference\n    }\n};"
      ],
      "tags": [
        "semantics",
        "memory-leak",
        "ownership",
        "deinit-pattern"
      ],
      "language": "zig",
      "domain": "semantics"
    },
    {
      "id": "zig-semantics-003",
      "name": "Comptime Assertions",
      "description": "Use @compileError to prevent impossible or unsafe states at compile time",
      "scenario": "Developer enforcing type constraints that must be verified at compile time",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "comptime type",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "sum",
            "params": [
              {
                "name": "comptime_T",
                "type_expr": "type",
                "scope": "parameter"
              },
              {
                "name": "slice",
                "type_expr": "[]const T",
                "scope": "parameter"
              }
            ],
            "return_type": "T"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "@typeInfo(T) == .Int or @typeInfo(T) == .Float",
            "scope": "sum",
            "variables": [
              "T"
            ]
          },
          {
            "kind": "assertion",
            "expression": "comptime check: T is numeric type",
            "scope": "sum",
            "variables": [
              "T"
            ]
          }
        ],
        "domain_configs": {
          "semantic": {
            "require_comptime_validation": true,
            "enforce_type_constraints": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks code without comptime type validation; requires @compileError for invalid types",
      "valid_outputs": [
        "pub fn sum(comptime T: type, slice: []const T) T {\n    const info = @typeInfo(T);\n    if (info != .Int and info != .Float) {\n        @compileError(\"sum() requires numeric type\");\n    }\n    var total: T = 0;\n    for (slice) |item| { total += item; }\n    return total;\n}",
        "pub fn sum(comptime T: type, slice: []const T) T {\n    comptime {\n        switch (@typeInfo(T)) {\n            .Int, .Float => {},\n            else => @compileError(\"T must be Int or Float\"),\n        }\n    }\n    var result: T = 0;\n    for (slice) |value| { result += value; }\n    return result;\n}",
        "fn sum(comptime T: type, slice: []const T) T {\n    if (!@typeInfo(T).Int and !@typeInfo(T).Float) {\n        @compileError(\"Unsupported type for sum\");\n    }\n    var s: T = 0;\n    for (slice) |x| s += x;\n    return s;\n}"
      ],
      "invalid_outputs": [
        "pub fn sum(comptime T: type, slice: []const T) T {\n    var total: T = 0;\n    for (slice) |item| { total += item; }\n    return total;\n}",
        "pub fn sum(comptime T: type, slice: []const T) T {\n    if (@typeInfo(T) != .Int) {\n        return error.InvalidType;\n    }\n    ...\n}",
        "pub fn sum(comptime T: type, slice: []const T) T {\n    std.debug.assert(@typeInfo(T) == .Int);\n    ...\n}"
      ],
      "tags": [
        "semantics",
        "comptime",
        "compile-error",
        "type-safety",
        "assertions"
      ],
      "language": "zig",
      "domain": "semantics"
    },
    {
      "id": "zig-syntax-001",
      "name": "Build.zig Configuration Schema",
      "description": "Enforce valid Build.zig structure with proper std.Build API usage",
      "scenario": "Developer creating build configuration following Zig build system conventions",
      "spec": {
        "version": "1.0",
        "structural_tag": "build_zig_file",
        "language": "zig",
        "type_bindings": [
          {
            "name": "b",
            "type_expr": "*std.Build",
            "scope": "parameter"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "assertion",
            "expression": "function_name == 'build'",
            "scope": "module"
          },
          {
            "kind": "assertion",
            "expression": "parameter_type == '*std.Build'",
            "scope": "build",
            "variables": [
              "b"
            ]
          }
        ],
        "domain_configs": {
          "syntax": {
            "enforce_build_convention": true,
            "require_pub_fn": true
          }
        },
        "cache_scope": "syntax_and_lang"
      },
      "expected_effect": "Masks non-conformant Build.zig syntax; requires pub fn build(b: *std.Build) void signature",
      "valid_outputs": [
        "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n    const exe = b.addExecutable(.{\n        .name = \"myapp\",\n        .root_source_file = .{ .path = \"src/main.zig\" },\n        .target = target,\n        .optimize = optimize,\n    });\n    b.installArtifact(exe);\n}",
        "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const lib = b.addStaticLibrary(.{\n        .name = \"mylib\",\n        .root_source_file = .{ .path = \"src/lib.zig\" },\n        .target = b.standardTargetOptions(.{}),\n        .optimize = b.standardOptimizeOption(.{}),\n    });\n    b.installArtifact(lib);\n    const tests = b.addTest(.{\n        .root_source_file = .{ .path = \"src/lib.zig\" },\n    });\n    const test_step = b.step(\"test\", \"Run tests\");\n    test_step.dependOn(&b.addRunArtifact(tests).step);\n}"
      ],
      "invalid_outputs": [
        "pub fn main(b: *std.Build) void { ... }",
        "fn build(b: *std.Build) void { ... }",
        "pub fn build(builder: *Builder) void { ... }",
        "pub fn build(b: std.Build) void { ... }"
      ],
      "tags": [
        "syntax",
        "build-system",
        "conventions",
        "structure"
      ],
      "language": "zig",
      "domain": "syntax"
    },
    {
      "id": "zig-syntax-002",
      "name": "Identifier Pattern snake_case",
      "description": "Enforce snake_case naming convention for Zig identifiers",
      "scenario": "Developer writing Zig code following community style guidelines",
      "spec": {
        "version": "1.0",
        "regex": "^[a-z][a-z0-9_]*$",
        "language": "zig",
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "identifier matches snake_case pattern",
            "scope": "module"
          }
        ],
        "domain_configs": {
          "syntax": {
            "naming_convention": "snake_case",
            "allow_leading_underscore": false,
            "check_function_names": true,
            "check_variable_names": true
          }
        },
        "cache_scope": "syntax_and_lang"
      },
      "expected_effect": "Masks identifiers not in snake_case; enforces lowercase with underscores",
      "valid_outputs": [
        "const max_buffer_size = 1024;",
        "fn process_user_input(data: []const u8) void { }",
        "var connection_count: u32 = 0;",
        "pub fn init_database() !void { }",
        "const ServerConfig = struct { port: u16 };"
      ],
      "invalid_outputs": [
        "const maxBufferSize = 1024;",
        "fn ProcessUserInput(data: []const u8) void { }",
        "var ConnectionCount: u32 = 0;",
        "const MAX_BUFFER_SIZE = 1024;"
      ],
      "tags": [
        "syntax",
        "naming",
        "conventions",
        "style"
      ],
      "language": "zig",
      "domain": "syntax"
    },
    {
      "id": "zig-syntax-003",
      "name": "Comptime Format String Validation",
      "description": "Validate format strings at compile time for std.fmt functions",
      "scenario": "Developer using std.debug.print with type-safe format strings",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "format",
            "type_expr": "[]const u8",
            "scope": "parameter",
            "mutable": false
          },
          {
            "name": "args",
            "type_expr": "anytype",
            "scope": "parameter"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "format is comptime-known string literal",
            "scope": "print",
            "variables": [
              "format"
            ]
          },
          {
            "kind": "assertion",
            "expression": "format_specifiers match args.len",
            "scope": "print",
            "variables": [
              "format",
              "args"
            ]
          }
        ],
        "domain_configs": {
          "syntax": {
            "validate_format_strings": true,
            "require_comptime_format": true,
            "check_format_args_match": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks format strings with mismatched placeholders; validates at compile time",
      "valid_outputs": [
        "std.debug.print(\"Value: {}\\n\", .{42});",
        "std.debug.print(\"x={}, y={}\\n\", .{ x, y });",
        "std.debug.print(\"Name: {s}, Age: {}\\n\", .{ name, age });",
        "const msg = \"Result: {d:.2}\\n\";\nstd.debug.print(msg, .{3.14159});",
        "std.debug.print(\"Status: {s}\\n\", .{@tagName(status)});"
      ],
      "invalid_outputs": [
        "std.debug.print(\"Value: {}, {}\\n\", .{42});",
        "std.debug.print(\"Value: {}\\n\", .{ 42, 43 });",
        "std.debug.print(\"Value: {d}\\n\", .{\"string\"});",
        "var fmt = \"Value: {}\\n\";\nstd.debug.print(fmt, .{42});"
      ],
      "tags": [
        "syntax",
        "format-strings",
        "type-safety",
        "comptime-validation"
      ],
      "language": "zig",
      "domain": "syntax"
    },
    {
      "id": "zig-comptime-001",
      "name": "Generic Data Structure with Comptime",
      "description": "Implement generic ArrayList-like container using comptime type parameters",
      "scenario": "Developer creating a reusable generic container with compile-time specialization",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "class_definitions": [
          {
            "name": "List",
            "type_params": [
              "T"
            ],
            "methods": [
              {
                "name": "init",
                "params": [
                  {
                    "name": "allocator",
                    "type_expr": "std.mem.Allocator",
                    "scope": "parameter"
                  }
                ],
                "return_type": "List(T)"
              },
              {
                "name": "deinit",
                "params": [
                  {
                    "name": "self",
                    "type_expr": "*List(T)",
                    "scope": "parameter"
                  }
                ],
                "return_type": "void"
              },
              {
                "name": "append",
                "params": [
                  {
                    "name": "self",
                    "type_expr": "*List(T)",
                    "scope": "parameter"
                  },
                  {
                    "name": "item",
                    "type_expr": "T",
                    "scope": "parameter"
                  }
                ],
                "return_type": "!void"
              }
            ],
            "instance_vars": [
              {
                "name": "allocator",
                "type_expr": "std.mem.Allocator"
              },
              {
                "name": "items",
                "type_expr": "[]T"
              },
              {
                "name": "capacity",
                "type_expr": "usize"
              }
            ]
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "items.len <= capacity",
            "scope": "List",
            "variables": [
              "items",
              "capacity"
            ]
          },
          {
            "kind": "postcondition",
            "expression": "after deinit: items.ptr == null",
            "scope": "List.deinit",
            "variables": [
              "self"
            ]
          }
        ],
        "domain_configs": {
          "comptime": {
            "require_generic_fn": true,
            "enforce_type_parameter": true,
            "check_comptime_evaluation": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks non-generic implementations; requires proper comptime type parameterization",
      "valid_outputs": [
        "pub fn List(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        allocator: std.mem.Allocator,\n        items: []T,\n        capacity: usize,\n\n        pub fn init(allocator: std.mem.Allocator) Self {\n            return Self{\n                .allocator = allocator,\n                .items = &[_]T{},\n                .capacity = 0,\n            };\n        }\n\n        pub fn deinit(self: *Self) void {\n            if (self.capacity > 0) {\n                self.allocator.free(self.items.ptr[0..self.capacity]);\n            }\n        }\n\n        pub fn append(self: *Self, item: T) !void {\n            if (self.items.len >= self.capacity) {\n                try self.grow();\n            }\n            self.items.len += 1;\n            self.items[self.items.len - 1] = item;\n        }\n\n        fn grow(self: *Self) !void {\n            const new_capacity = if (self.capacity == 0) 8 else self.capacity * 2;\n            const new_memory = try self.allocator.alloc(T, new_capacity);\n            if (self.capacity > 0) {\n                @memcpy(new_memory[0..self.items.len], self.items);\n                self.allocator.free(self.items.ptr[0..self.capacity]);\n            }\n            self.items.ptr = new_memory.ptr;\n            self.capacity = new_capacity;\n        }\n    };\n}",
        "fn List(comptime T: type) type {\n    return struct {\n        allocator: std.mem.Allocator,\n        items: []T,\n        capacity: usize,\n\n        const Self = @This();\n\n        pub fn init(allocator: std.mem.Allocator) Self {\n            return .{ .allocator = allocator, .items = &.{}, .capacity = 0 };\n        }\n\n        pub fn deinit(self: *Self) void {\n            if (self.items.ptr) |ptr| {\n                self.allocator.free(ptr[0..self.capacity]);\n            }\n        }\n\n        pub fn append(self: *Self, item: T) !void {\n            if (self.items.len == self.capacity) {\n                const new_cap = @max(8, self.capacity * 2);\n                const new_mem = try self.allocator.realloc(self.items.ptr[0..self.capacity], new_cap);\n                self.items.ptr = new_mem.ptr;\n                self.capacity = new_cap;\n            }\n            self.items.len += 1;\n            self.items[self.items.len - 1] = item;\n        }\n    };\n}"
      ],
      "invalid_outputs": [
        "pub const List = struct { items: []anyopaque, ... };",
        "pub fn List(T: type) type { ... }",
        "pub fn List(comptime T: type) struct { ... }"
      ],
      "tags": [
        "comptime",
        "generics",
        "data-structures",
        "metaprogramming"
      ],
      "language": "zig",
      "domain": "comptime"
    },
    {
      "id": "zig-comptime-002",
      "name": "Custom Allocator Pattern",
      "description": "Implement custom allocator conforming to std.mem.Allocator interface",
      "scenario": "Developer creating arena allocator with proper Allocator interface",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "class_definitions": [
          {
            "name": "ArenaAllocator",
            "methods": [
              {
                "name": "init",
                "params": [
                  {
                    "name": "child",
                    "type_expr": "std.mem.Allocator",
                    "scope": "parameter"
                  }
                ],
                "return_type": "ArenaAllocator"
              },
              {
                "name": "allocator",
                "params": [
                  {
                    "name": "self",
                    "type_expr": "*ArenaAllocator",
                    "scope": "parameter"
                  }
                ],
                "return_type": "std.mem.Allocator"
              },
              {
                "name": "alloc",
                "params": [
                  {
                    "name": "ctx",
                    "type_expr": "*anyopaque",
                    "scope": "parameter"
                  },
                  {
                    "name": "len",
                    "type_expr": "usize",
                    "scope": "parameter"
                  },
                  {
                    "name": "ptr_align",
                    "type_expr": "u8",
                    "scope": "parameter"
                  },
                  {
                    "name": "ret_addr",
                    "type_expr": "usize",
                    "scope": "parameter"
                  }
                ],
                "return_type": "?[*]u8"
              }
            ],
            "instance_vars": [
              {
                "name": "child_allocator",
                "type_expr": "std.mem.Allocator"
              },
              {
                "name": "buffer",
                "type_expr": "[]u8"
              },
              {
                "name": "offset",
                "type_expr": "usize"
              }
            ]
          }
        ],
        "semantic_constraints": [
          {
            "kind": "assertion",
            "expression": "allocator returns std.mem.Allocator vtable",
            "scope": "ArenaAllocator"
          },
          {
            "kind": "invariant",
            "expression": "offset <= buffer.len",
            "scope": "ArenaAllocator",
            "variables": [
              "offset",
              "buffer"
            ]
          }
        ],
        "domain_configs": {
          "comptime": {
            "require_allocator_interface": true,
            "validate_vtable": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks allocator implementations not conforming to std.mem.Allocator interface",
      "valid_outputs": [
        "const ArenaAllocator = struct {\n    child_allocator: std.mem.Allocator,\n    buffer: []u8,\n    offset: usize,\n\n    const Self = @This();\n\n    pub fn init(child: std.mem.Allocator) Self {\n        return Self{\n            .child_allocator = child,\n            .buffer = &[_]u8{},\n            .offset = 0,\n        };\n    }\n\n    pub fn allocator(self: *Self) std.mem.Allocator {\n        return .{\n            .ptr = self,\n            .vtable = &.{\n                .alloc = alloc,\n                .resize = resize,\n                .free = free,\n            },\n        };\n    }\n\n    fn alloc(ctx: *anyopaque, len: usize, ptr_align: u8, ret_addr: usize) ?[*]u8 {\n        const self: *Self = @ptrCast(@alignCast(ctx));\n        _ = ret_addr;\n        const align_offset = std.mem.alignForward(usize, self.offset, ptr_align);\n        const new_offset = align_offset + len;\n        if (new_offset > self.buffer.len) {\n            const new_buffer = self.child_allocator.alloc(u8, new_offset * 2) catch return null;\n            @memcpy(new_buffer[0..self.offset], self.buffer[0..self.offset]);\n            if (self.buffer.len > 0) {\n                self.child_allocator.free(self.buffer);\n            }\n            self.buffer = new_buffer;\n        }\n        const result = self.buffer[align_offset..new_offset];\n        self.offset = new_offset;\n        return result.ptr;\n    }\n\n    fn resize(ctx: *anyopaque, buf: []u8, buf_align: u8, new_len: usize, ret_addr: usize) bool {\n        _ = ctx;\n        _ = buf;\n        _ = buf_align;\n        _ = new_len;\n        _ = ret_addr;\n        return false;\n    }\n\n    fn free(ctx: *anyopaque, buf: []u8, buf_align: u8, ret_addr: usize) void {\n        _ = ctx;\n        _ = buf;\n        _ = buf_align;\n        _ = ret_addr;\n    }\n};"
      ],
      "invalid_outputs": [
        "const ArenaAllocator = struct {\n    pub fn alloc(self: *Self, size: usize) ![]u8 { ... }\n};",
        "const ArenaAllocator = struct {\n    pub fn allocator(self: *Self) Allocator { ... }\n};",
        "const ArenaAllocator = struct {\n    // Missing vtable implementation\n};"
      ],
      "tags": [
        "comptime",
        "allocator",
        "interface",
        "vtable",
        "memory-management"
      ],
      "language": "zig",
      "domain": "comptime"
    },
    {
      "id": "zig-comptime-003",
      "name": "Error Set Inference and Composition",
      "description": "Compose and infer error sets across function boundaries",
      "scenario": "Developer building error handling hierarchy with automatic error set inference",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "ConfigError",
            "type_expr": "error{ FileNotFound, ParseError, InvalidFormat }",
            "scope": "module"
          }
        ],
        "function_signatures": [
          {
            "name": "readConfig",
            "params": [
              {
                "name": "path",
                "type_expr": "[]const u8",
                "scope": "parameter"
              }
            ],
            "return_type": "!Config"
          },
          {
            "name": "parseConfig",
            "params": [
              {
                "name": "data",
                "type_expr": "[]const u8",
                "scope": "parameter"
              }
            ],
            "return_type": "!Config"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "readConfig error set \u2287 parseConfig error set",
            "scope": "module"
          },
          {
            "kind": "assertion",
            "expression": "error set inferred from called functions",
            "scope": "readConfig"
          }
        ],
        "domain_configs": {
          "comptime": {
            "infer_error_sets": true,
            "compose_error_unions": true,
            "validate_error_coverage": true
          }
        },
        "cache_scope": "full_context"
      },
      "expected_effect": "Masks explicit error sets where inference should apply; validates error set composition",
      "valid_outputs": [
        "const ConfigError = error{\n    FileNotFound,\n    ParseError,\n    InvalidFormat,\n};\n\nconst Config = struct {\n    name: []const u8,\n    port: u16,\n};\n\nfn parseConfig(data: []const u8) ConfigError!Config {\n    if (data.len == 0) return error.InvalidFormat;\n    // Parse logic\n    return Config{ .name = \"default\", .port = 8080 };\n}\n\nfn readConfig(path: []const u8) !Config {\n    const file = std.fs.cwd().openFile(path, .{}) catch return error.FileNotFound;\n    defer file.close();\n\n    const data = file.readToEndAlloc(std.heap.page_allocator, 1024 * 1024) catch return error.ParseError;\n    defer std.heap.page_allocator.free(data);\n\n    return try parseConfig(data);\n}",
        "const ParseError = error{ InvalidFormat, MissingField };\nconst IOError = error{ FileNotFound, ReadError };\n\nfn parseConfig(data: []const u8) ParseError!Config {\n    if (data.len == 0) return error.InvalidFormat;\n    return Config{ .name = \"config\", .port = 3000 };\n}\n\nfn readConfig(path: []const u8) (IOError || ParseError)!Config {\n    const file = std.fs.cwd().openFile(path, .{}) catch return error.FileNotFound;\n    defer file.close();\n    const contents = file.readToEndAlloc(allocator, 1024) catch return error.ReadError;\n    defer allocator.free(contents);\n    return try parseConfig(contents);\n}",
        "fn parseConfig(data: []const u8) !Config {\n    // Inferred error set from std.fmt.parseInt and other operations\n    const port = try std.fmt.parseInt(u16, data, 10);\n    return Config{ .name = \"app\", .port = port };\n}\n\nfn readConfig(path: []const u8) !Config {\n    // Inferred error set includes parseConfig errors + file errors\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n    const data = try file.readToEndAlloc(allocator, 4096);\n    defer allocator.free(data);\n    return try parseConfig(data);\n}"
      ],
      "invalid_outputs": [
        "fn readConfig(path: []const u8) ConfigError!Config {\n    return try parseConfig(data);\n}",
        "fn parseConfig(data: []const u8) anyerror!Config { ... }",
        "fn readConfig(path: []const u8) error{ParseError}!Config {\n    const file = try std.fs.cwd().openFile(path, .{});\n}"
      ],
      "tags": [
        "comptime",
        "error-sets",
        "error-handling",
        "inference",
        "composition"
      ],
      "language": "zig",
      "domain": "comptime"
    },
    {
      "id": "ts-types-001",
      "name": "Conditional Type Extraction",
      "description": "Extract element type from array using conditional types",
      "scenario": "Developer writing a utility type to extract the element type from an array type. Given Array<string>, should produce string. Given Promise<number[]>, should extract number. Uses T extends Array<infer U> pattern for type inference.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "Array<infer U>",
            "scope": "type_parameter"
          }
        ],
        "expected_type": "U",
        "type_aliases": {
          "ArrayElement": "T extends Array<infer U> ? U : never"
        }
      },
      "expected_effect": "Masks tokens that would produce types inconsistent with the conditional type pattern. Ensures the inferred type U is properly extracted from the array structure. Blocks patterns that don't match Array<T> or don't use infer correctly.",
      "valid_outputs": [
        "type ArrayElement<T> = T extends Array<infer U> ? U : never;",
        "type ArrayElement<T> = T extends (infer U)[] ? U : never;",
        "type ArrayElement<T> = T extends ReadonlyArray<infer U> ? U : never;"
      ],
      "invalid_outputs": [
        "type ArrayElement<T> = T[0];",
        "type ArrayElement<T> = T extends Array<U> ? U : never;",
        "type ArrayElement<T> = T extends infer U ? U : never;",
        "type ArrayElement<T> = Array<T>;"
      ],
      "tags": [
        "types",
        "conditional",
        "inference",
        "utility-types"
      ],
      "language": "typescript",
      "domain": "types"
    },
    {
      "id": "ts-types-002",
      "name": "Mapped Type Transformation",
      "description": "Create readonly version of type using mapped types",
      "scenario": "Developer implementing a DeepReadonly<T> utility type that recursively makes all properties and nested properties readonly. This demonstrates mapped type patterns with recursive conditional types.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "object",
            "scope": "type_parameter"
          }
        ],
        "expected_type": "DeepReadonly<T>",
        "type_aliases": {
          "DeepReadonly": "{readonly [P in keyof T]: DeepReadonly<T[P]>}"
        }
      },
      "expected_effect": "Masks tokens that would create mutable properties or fail to recurse into nested objects. Ensures all properties are marked readonly and the type recursively applies to nested object structures.",
      "valid_outputs": [
        "type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> };",
        "type DeepReadonly<T> = T extends object ? { readonly [P in keyof T]: DeepReadonly<T[P]> } : T;",
        "type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] };"
      ],
      "invalid_outputs": [
        "type DeepReadonly<T> = { [P in keyof T]: T[P] };",
        "type DeepReadonly<T> = Readonly<T>;",
        "type DeepReadonly<T> = { readonly [P in keyof T]: T[P] };",
        "type DeepReadonly<T> = T;"
      ],
      "tags": [
        "types",
        "mapped",
        "readonly",
        "utility-types",
        "recursive"
      ],
      "language": "typescript",
      "domain": "types"
    },
    {
      "id": "ts-types-003",
      "name": "Template Literal Type Pattern",
      "description": "Generate event handler type names from events",
      "scenario": "Developer creating a type system for React-like event handlers where event names like 'click', 'focus', 'blur' are automatically transformed to handler names like 'onClick', 'onFocus', 'onBlur' using template literal types with Capitalize utility.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "E",
            "type_expr": "string",
            "scope": "type_parameter"
          }
        ],
        "expected_type": "EventHandler<E>",
        "type_aliases": {
          "EventHandler": "`on${Capitalize<E>}`",
          "EventMap": "{ [K in keyof Events as `on${Capitalize<K>}`]: (event: Events[K]) => void }"
        }
      },
      "expected_effect": "Masks tokens that don't follow the template literal type pattern. Ensures event handler names are correctly prefixed with 'on' and the first letter is capitalized. Blocks raw concatenation or incorrect transformation patterns.",
      "valid_outputs": [
        "type EventHandler<E extends string> = `on${Capitalize<E>}`;",
        "type EventHandlers<Events> = { [K in keyof Events as `on${Capitalize<K & string>}`]: (event: Events[K]) => void };",
        "type Handler<E extends string> = `on${Capitalize<E>}Handler`;"
      ],
      "invalid_outputs": [
        "type EventHandler<E extends string> = `on${E}`;",
        "type EventHandler<E extends string> = E;",
        "type EventHandler<E extends string> = 'on' + E;",
        "type EventHandler<E extends string> = string;"
      ],
      "tags": [
        "types",
        "template-literals",
        "string-manipulation",
        "events"
      ],
      "language": "typescript",
      "domain": "types"
    },
    {
      "id": "ts-imports-001",
      "name": "ESM vs CommonJS Module Resolution",
      "description": "Enforce proper ESM import syntax for TypeScript modules",
      "scenario": "Developer working in a TypeScript project with 'type': 'module' in package.json, requiring ESM import syntax. Must use 'import' statements rather than 'require()' and properly handle default vs named exports. The constraint ensures generated imports follow ESM conventions.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "imports": [
          {
            "module": "fs",
            "name": "promises",
            "alias": "fs"
          },
          {
            "module": "express"
          }
        ],
        "available_modules": [
          "express",
          "fs",
          "fs/promises",
          "path",
          "url"
        ],
        "module_stubs": {
          "express": {
            "module_name": "express",
            "exports": {
              "default": "() => Express",
              "Router": "() => Router"
            }
          },
          "fs/promises": {
            "module_name": "fs/promises",
            "exports": {
              "readFile": "(path: string) => Promise<Buffer>",
              "writeFile": "(path: string, data: string) => Promise<void>"
            }
          }
        }
      },
      "expected_effect": "Masks tokens that would generate CommonJS syntax (require, module.exports) instead of ESM syntax (import, export). Ensures proper handling of default exports with 'import X from' vs named exports with 'import { X } from'.",
      "valid_outputs": [
        "import express from 'express';",
        "import { Router } from 'express';",
        "import { readFile, writeFile } from 'fs/promises';",
        "import * as fs from 'fs/promises';",
        "import type { Express } from 'express';"
      ],
      "invalid_outputs": [
        "const express = require('express');",
        "import express = require('express');",
        "const { Router } = require('express');",
        "module.exports = express;"
      ],
      "tags": [
        "imports",
        "esm",
        "commonjs",
        "module-resolution"
      ],
      "language": "typescript",
      "domain": "imports"
    },
    {
      "id": "ts-imports-002",
      "name": "Type-Only Import Distinction",
      "description": "Enforce type vs value import separation for tree-shaking",
      "scenario": "Developer optimizing bundle size by separating type imports from value imports. Types should use 'import type' syntax to ensure they're erased at runtime and don't affect bundle size. This is especially important when importing large type definition files.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_aliases": {
          "ComponentType": "Type[React.ComponentType<any>]",
          "FC": "Type[React.FunctionComponent<P>]"
        },
        "imports": [
          {
            "module": "react",
            "name": "ComponentType"
          },
          {
            "module": "react",
            "name": "FC"
          }
        ],
        "available_modules": [
          "@types/react",
          "react"
        ],
        "module_stubs": {
          "react": {
            "module_name": "react",
            "exports": {
              "useState": "<T>(initial: T) => [T, (value: T) => void]",
              "useEffect": "(effect: () => void, deps?: any[]) => void",
              "ComponentType": "Type",
              "FC": "Type"
            }
          }
        }
      },
      "expected_effect": "Masks tokens that import types as values or vice versa. Ensures type imports use 'import type { X }' syntax for tree-shaking. Allows value imports to use regular 'import { X }' syntax. Blocks mixing type and value imports in the same statement when isolatedModules is enabled.",
      "valid_outputs": [
        "import type { ComponentType, FC } from 'react';",
        "import { useState, useEffect } from 'react';",
        "import React, { type ComponentType } from 'react';",
        "import type * as React from 'react';"
      ],
      "invalid_outputs": [
        "import { ComponentType, useState } from 'react';",
        "import type { useState } from 'react';",
        "import ComponentType from 'react';",
        "import { type useState } from 'react';"
      ],
      "tags": [
        "imports",
        "type-only",
        "tree-shaking",
        "optimization"
      ],
      "language": "typescript",
      "domain": "imports"
    },
    {
      "id": "ts-imports-003",
      "name": "Path Alias Resolution",
      "description": "Resolve TypeScript path aliases from tsconfig.json",
      "scenario": "Developer using path aliases configured in tsconfig.json to avoid relative import hell. Common patterns include '@/' for src root, '@components/' for components directory. Must ensure imports resolve to actual file paths and respect the module resolution strategy.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_aliases": {
          "@/*": "src/*",
          "@components/*": "src/components/*",
          "@utils/*": "src/utils/*"
        },
        "imports": [
          {
            "module": "@/components/Button",
            "name": "Button"
          },
          {
            "module": "@/utils/format",
            "name": "formatDate"
          }
        ],
        "available_modules": [
          "@/components/Button",
          "@/types/user",
          "@/utils/format",
          "src/components/Button",
          "src/utils/format"
        ],
        "module_stubs": {
          "@/components/Button": {
            "module_name": "@/components/Button",
            "exports": {
              "Button": "React.FC<ButtonProps>",
              "ButtonProps": "Type"
            }
          },
          "@/utils/format": {
            "module_name": "@/utils/format",
            "exports": {
              "formatDate": "(date: Date) => string"
            }
          }
        }
      },
      "expected_effect": "Masks tokens that would create invalid import paths or fail to use configured aliases. Ensures imports use the @/ alias pattern rather than relative paths like '../../../components/Button'. Validates that aliased paths resolve to actual modules.",
      "valid_outputs": [
        "import { Button } from '@/components/Button';",
        "import { formatDate } from '@/utils/format';",
        "import type { ButtonProps } from '@/components/Button';",
        "import * as utils from '@/utils/format';"
      ],
      "invalid_outputs": [
        "import { Button } from '../../../components/Button';",
        "import { Button } from 'components/Button';",
        "import { Button } from '@components/Button';",
        "import { Button } from '@/Button';"
      ],
      "tags": [
        "imports",
        "path-aliases",
        "module-resolution",
        "tsconfig"
      ],
      "language": "typescript",
      "domain": "imports"
    },
    {
      "id": "ts-controlflow-001",
      "name": "Discriminated Union Exhaustiveness",
      "description": "Ensure all union variants are handled in switch statement",
      "scenario": "Developer implementing a reducer pattern with discriminated unions representing different action types. TypeScript's control flow analysis should ensure all action types are handled, with the default case using 'never' to catch unhandled variants at compile time.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "action",
            "type_expr": "Action",
            "scope": "parameter"
          },
          {
            "name": "state",
            "type_expr": "State",
            "scope": "parameter"
          }
        ],
        "type_aliases": {
          "Action": "{ type: 'increment'; amount: number } | { type: 'decrement'; amount: number } | { type: 'reset' }",
          "State": "{ count: number }"
        },
        "control_flow": {
          "function_name": "reducer",
          "function_signature": {
            "name": "reducer",
            "params": [
              {
                "name": "state",
                "type_expr": "State"
              },
              {
                "name": "action",
                "type_expr": "Action"
              }
            ],
            "return_type": "State"
          },
          "expected_return_type": "State"
        }
      },
      "expected_effect": "Masks tokens that would create non-exhaustive switch statements or miss handling a discriminated union variant. Ensures the default case assigns action to 'never' type, proving all variants are covered. Blocks code that doesn't handle all action.type values.",
      "valid_outputs": [
        "switch (action.type) {\n  case 'increment':\n    return { count: state.count + action.amount };\n  case 'decrement':\n    return { count: state.count - action.amount };\n  case 'reset':\n    return { count: 0 };\n  default:\n    const _exhaustive: never = action;\n    return state;\n}",
        "switch (action.type) {\n  case 'increment':\n    return { count: state.count + action.amount };\n  case 'decrement':\n    return { count: state.count - action.amount };\n  case 'reset':\n    return { count: 0 };\n  default:\n    throw new Error(`Unhandled action type: ${(action as any).type}`);\n}"
      ],
      "invalid_outputs": [
        "switch (action.type) {\n  case 'increment':\n    return { count: state.count + action.amount };\n  case 'decrement':\n    return { count: state.count - action.amount };\n}",
        "switch (action.type) {\n  case 'increment':\n    return { count: state.count + action.amount };\n  default:\n    return state;\n}",
        "if (action.type === 'increment') {\n  return { count: state.count + action.amount };\n}\nreturn state;"
      ],
      "tags": [
        "controlflow",
        "discriminated-unions",
        "exhaustiveness",
        "switch"
      ],
      "language": "typescript",
      "domain": "controlflow"
    },
    {
      "id": "ts-controlflow-002",
      "name": "Async/Await Promise Context",
      "description": "Enforce proper async/await usage and Promise type handling",
      "scenario": "Developer writing async function that fetches data from an API and processes it. Must properly await Promise values before using them, and ensure return type matches declared Promise<T>. TypeScript's control flow should track Promise contexts and prevent using Promise values as if they were resolved.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "userId",
            "type_expr": "string",
            "scope": "parameter"
          },
          {
            "name": "response",
            "type_expr": "Promise<Response>",
            "scope": "local"
          },
          {
            "name": "data",
            "type_expr": "User",
            "scope": "local"
          }
        ],
        "type_aliases": {
          "User": "{ id: string; name: string; email: string }"
        },
        "control_flow": {
          "function_name": "fetchUser",
          "function_signature": {
            "name": "fetchUser",
            "params": [
              {
                "name": "userId",
                "type_expr": "string"
              }
            ],
            "return_type": "Promise<User>",
            "is_async": true
          },
          "expected_return_type": "Promise<User>",
          "in_async_context": true
        }
      },
      "expected_effect": "Masks tokens that would use Promise values without awaiting them, or return non-Promise values from async functions. Ensures fetch results are awaited before accessing properties. Blocks synchronous operations on Promise types.",
      "valid_outputs": [
        "async function fetchUser(userId: string): Promise<User> {\n  const response = await fetch(`/api/users/${userId}`);\n  const data = await response.json();\n  return data;\n}",
        "async function fetchUser(userId: string): Promise<User> {\n  const response = await fetch(`/api/users/${userId}`);\n  if (!response.ok) throw new Error('Fetch failed');\n  return await response.json();\n}",
        "async function fetchUser(userId: string): Promise<User> {\n  try {\n    const response = await fetch(`/api/users/${userId}`);\n    return await response.json();\n  } catch (error) {\n    throw new Error('Failed to fetch user');\n  }\n}"
      ],
      "invalid_outputs": [
        "async function fetchUser(userId: string): Promise<User> {\n  const response = fetch(`/api/users/${userId}`);\n  return response.json();\n}",
        "function fetchUser(userId: string): Promise<User> {\n  const response = await fetch(`/api/users/${userId}`);\n  return response.json();\n}",
        "async function fetchUser(userId: string): Promise<User> {\n  const response = fetch(`/api/users/${userId}`);\n  return response.data;\n}"
      ],
      "tags": [
        "controlflow",
        "async",
        "await",
        "promises"
      ],
      "language": "typescript",
      "domain": "controlflow"
    },
    {
      "id": "ts-controlflow-003",
      "name": "Never Type in Unreachable Code",
      "description": "Use 'never' type to mark unreachable code paths",
      "scenario": "Developer implementing error handling where certain code paths should be statically proven unreachable. Uses 'never' type annotations to make control flow guarantees explicit. TypeScript's control flow analysis ensures functions that never return are properly typed.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "error",
            "type_expr": "Error",
            "scope": "parameter"
          },
          {
            "name": "message",
            "type_expr": "string",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "assertNever",
          "function_signature": {
            "name": "assertNever",
            "params": [
              {
                "name": "value",
                "type_expr": "never"
              }
            ],
            "return_type": "never"
          },
          "expected_return_type": "never",
          "reachable": false
        }
      },
      "expected_effect": "Masks tokens that would create reachable return paths in functions marked with 'never' return type. Ensures functions that should never return (like error throwers) actually throw or loop infinitely. Blocks normal return statements or code after exhaustive checks.",
      "valid_outputs": [
        "function assertNever(value: never): never {\n  throw new Error(`Unexpected value: ${value}`);\n}",
        "function fail(message: string): never {\n  throw new Error(message);\n}",
        "function infiniteLoop(): never {\n  while (true) {\n    console.log('running');\n  }\n}",
        "function processExit(): never {\n  process.exit(1);\n}"
      ],
      "invalid_outputs": [
        "function assertNever(value: never): never {\n  console.error(`Unexpected value: ${value}`);\n  return;\n}",
        "function assertNever(value: never): never {\n  if (value) {\n    throw new Error('error');\n  }\n}",
        "function assertNever(value: never): never {\n  console.error(value);\n}"
      ],
      "tags": [
        "controlflow",
        "never",
        "exhaustiveness",
        "unreachable"
      ],
      "language": "typescript",
      "domain": "controlflow"
    },
    {
      "id": "ts-semantics-001",
      "name": "Non-Null Assertion Justification",
      "description": "Justify use of non-null assertion operator (!)",
      "scenario": "Developer using the non-null assertion operator (!) to tell TypeScript that a potentially null/undefined value is definitely defined. This should only be used when there's a runtime guarantee (like after a null check, or when dealing with DOM elements known to exist). The constraint ensures the assertion is justified by context.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "element",
            "type_expr": "HTMLElement | null",
            "scope": "local"
          },
          {
            "name": "user",
            "type_expr": "User | undefined",
            "scope": "local"
          }
        ],
        "type_aliases": {
          "User": "{ id: string; name: string }"
        },
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "element !== null",
            "scope": "local",
            "variables": [
              "element"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would use non-null assertion (!) without proper justification. Requires prior null check or context proving the value is non-null. Blocks unsafe assertions that could cause runtime errors. Allows assertions after explicit checks like 'if (x !== null)'.",
      "valid_outputs": [
        "const element = document.getElementById('app');\nif (element !== null) {\n  element.style.color = 'red';\n}",
        "const element = document.getElementById('app');\nif (!element) throw new Error('Element not found');\nelement.style.color = 'red';",
        "function process(user: User | undefined): string {\n  if (user === undefined) {\n    return 'No user';\n  }\n  return user.name;\n}"
      ],
      "invalid_outputs": [
        "const element = document.getElementById('app');\nelement!.style.color = 'red';",
        "function process(user: User | undefined): string {\n  return user!.name;\n}",
        "const element = document.querySelector('.item');\nelement!.textContent = 'text';"
      ],
      "tags": [
        "semantics",
        "non-null",
        "assertions",
        "safety"
      ],
      "language": "typescript",
      "domain": "semantics"
    },
    {
      "id": "ts-semantics-002",
      "name": "Readonly Enforcement",
      "description": "Enforce readonly property constraints",
      "scenario": "Developer working with readonly properties and arrays where mutation should be prevented. TypeScript's readonly modifier and ReadonlyArray type prevent accidental mutations. The constraint ensures code doesn't attempt to modify readonly data structures.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "config",
            "type_expr": "Readonly<Config>",
            "scope": "parameter",
            "mutable": false
          },
          {
            "name": "items",
            "type_expr": "ReadonlyArray<string>",
            "scope": "parameter",
            "mutable": false
          }
        ],
        "type_aliases": {
          "Config": "{ apiUrl: string; timeout: number; retries: number }"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "config is not mutated",
            "scope": "function",
            "variables": [
              "config"
            ]
          },
          {
            "kind": "invariant",
            "expression": "items is not mutated",
            "scope": "function",
            "variables": [
              "items"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would mutate readonly properties or arrays. Blocks assignments to readonly properties (config.timeout = 5000), mutating array methods (items.push(), items.sort()), and any operations that modify readonly data in place. Allows reading and creating new objects.",
      "valid_outputs": [
        "function processConfig(config: Readonly<Config>): Config {\n  return { ...config, timeout: config.timeout * 2 };\n}",
        "function filterItems(items: ReadonlyArray<string>): string[] {\n  return items.filter(item => item.length > 0);\n}",
        "function updateConfig(config: Readonly<Config>): Readonly<Config> {\n  return Object.freeze({ ...config, retries: 5 });\n}"
      ],
      "invalid_outputs": [
        "function processConfig(config: Readonly<Config>): void {\n  config.timeout = 5000;\n}",
        "function filterItems(items: ReadonlyArray<string>): void {\n  items.push('new');\n}",
        "function updateConfig(config: Readonly<Config>): void {\n  config.apiUrl = 'new-url';\n  config.retries = 3;\n}"
      ],
      "tags": [
        "semantics",
        "readonly",
        "immutability",
        "mutation"
      ],
      "language": "typescript",
      "domain": "semantics"
    },
    {
      "id": "ts-semantics-003",
      "name": "Type Narrowing Exhaustiveness",
      "description": "Ensure exhaustive type narrowing with proper guards",
      "scenario": "Developer using type guards to narrow union types and ensure all variants are handled. After a type guard like 'typeof x === \"string\"', the type should be narrowed to string in that branch. The constraint ensures narrowing is complete and no cases are missed.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "value",
            "type_expr": "string | number | boolean",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "processValue",
          "expected_return_type": "string"
        },
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "all union variants are handled",
            "scope": "function",
            "variables": [
              "value"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would create non-exhaustive type narrowing or miss union variants. Ensures type guards cover all possibilities (string, number, boolean). Blocks code that only checks some types and leaves others unhandled, which would cause the function to implicitly return undefined.",
      "valid_outputs": [
        "function processValue(value: string | number | boolean): string {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  } else if (typeof value === 'number') {\n    return value.toString();\n  } else {\n    return value ? 'true' : 'false';\n  }\n}",
        "function processValue(value: string | number | boolean): string {\n  switch (typeof value) {\n    case 'string':\n      return value.toUpperCase();\n    case 'number':\n      return value.toString();\n    case 'boolean':\n      return value ? 'true' : 'false';\n    default:\n      const _exhaustive: never = value;\n      throw new Error('Unreachable');\n  }\n}"
      ],
      "invalid_outputs": [
        "function processValue(value: string | number | boolean): string {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  }\n  return value.toString();\n}",
        "function processValue(value: string | number | boolean): string {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  } else if (typeof value === 'number') {\n    return value.toString();\n  }\n}",
        "function processValue(value: string | number | boolean): string {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  }\n}"
      ],
      "tags": [
        "semantics",
        "type-narrowing",
        "exhaustiveness",
        "type-guards"
      ],
      "language": "typescript",
      "domain": "semantics"
    },
    {
      "id": "ts-syntax-001",
      "name": "OpenAPI Schema Definition",
      "description": "Generate TypeScript types from OpenAPI/Swagger schema",
      "scenario": "Developer working with OpenAPI specification and generating TypeScript types for API request/response objects. The schema defines a User object with required and optional fields, string formats, and nested objects. Generated types must match the JSON Schema exactly.",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n  \"type\": \"object\",\n  \"required\": [\"id\", \"email\", \"createdAt\"],\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"format\": \"uuid\"\n    },\n    \"email\": {\n      \"type\": \"string\",\n      \"format\": \"email\"\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"minLength\": 1,\n      \"maxLength\": 100\n    },\n    \"createdAt\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    },\n    \"profile\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"bio\": { \"type\": \"string\" },\n        \"avatarUrl\": { \"type\": \"string\", \"format\": \"uri\" }\n      }\n    }\n  },\n  \"additionalProperties\": false\n}",
        "language": "typescript"
      },
      "expected_effect": "Masks tokens that would create type definitions not matching the JSON Schema. Ensures required fields (id, email, createdAt) are non-optional, optional fields (name, profile) use ? modifier. Blocks additional properties due to additionalProperties: false. Enforces string types for all fields.",
      "valid_outputs": [
        "interface User {\n  id: string;\n  email: string;\n  name?: string;\n  createdAt: string;\n  profile?: {\n    bio?: string;\n    avatarUrl?: string;\n  };\n}",
        "type User = {\n  id: string;\n  email: string;\n  name?: string;\n  createdAt: string;\n  profile?: {\n    bio?: string;\n    avatarUrl?: string;\n  };\n};"
      ],
      "invalid_outputs": [
        "interface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: string;\n}",
        "interface User {\n  id: string;\n  email?: string;\n  name?: string;\n  createdAt: string;\n}",
        "interface User {\n  id: string;\n  email: string;\n  name?: string;\n  createdAt: string;\n  profile?: object;\n  extraField?: string;\n}"
      ],
      "tags": [
        "syntax",
        "json-schema",
        "openapi",
        "swagger"
      ],
      "language": "typescript",
      "domain": "syntax"
    },
    {
      "id": "ts-syntax-002",
      "name": "URL Pattern with Capture Groups",
      "description": "Parse URL with regex and extract route parameters",
      "scenario": "Developer implementing client-side routing with URL pattern matching. Must parse URLs like '/users/123/posts/456' and extract userId and postId. Uses regex with named capture groups to extract parameters in a type-safe way.",
      "spec": {
        "version": "1.0",
        "regex": "^/users/(?<userId>\\d+)/posts/(?<postId>\\d+)$",
        "language": "typescript"
      },
      "expected_effect": "Masks tokens that would create regex patterns not matching the URL structure. Ensures the pattern captures userId and postId as numeric strings. Blocks patterns without named capture groups or with incorrect anchoring (^/$). Enforces digit-only capture groups (\\d+).",
      "valid_outputs": [
        "const pattern = /^\\/users\\/(?<userId>\\d+)\\/posts\\/(?<postId>\\d+)$/;\nconst match = pattern.exec(url);\nif (match?.groups) {\n  const { userId, postId } = match.groups;\n  return { userId, postId };\n}",
        "const pattern = /^\\/users\\/(?<userId>\\d+)\\/posts\\/(?<postId>\\d+)$/;\nconst result = url.match(pattern);\nreturn result?.groups as { userId: string; postId: string } | undefined;"
      ],
      "invalid_outputs": [
        "const pattern = /\\/users\\/(\\d+)\\/posts\\/(\\d+)/;\nconst match = pattern.exec(url);\nreturn match ? { userId: match[1], postId: match[2] } : null;",
        "const pattern = /users\\/(?<userId>\\d+)\\/posts\\/(?<postId>\\d+)/;",
        "const pattern = /^\\/users\\/(?<userId>\\w+)\\/posts\\/(?<postId>\\w+)$/;"
      ],
      "tags": [
        "syntax",
        "regex",
        "url-routing",
        "capture-groups"
      ],
      "language": "typescript",
      "domain": "syntax"
    },
    {
      "id": "ts-syntax-003",
      "name": "GraphQL Query Schema",
      "description": "Define TypeScript types for GraphQL query results",
      "scenario": "Developer working with GraphQL API and generating TypeScript types for query results. The query fetches user data with nested posts and comments. Generated types must match the GraphQL schema structure including nullable fields and nested relationships.",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n  \"type\": \"object\",\n  \"required\": [\"user\"],\n  \"properties\": {\n    \"user\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\",\n          \"required\": [\"id\", \"username\", \"posts\"],\n          \"properties\": {\n            \"id\": { \"type\": \"string\" },\n            \"username\": { \"type\": \"string\" },\n            \"email\": { \"type\": \"string\" },\n            \"posts\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"object\",\n                \"required\": [\"id\", \"title\", \"comments\"],\n                \"properties\": {\n                  \"id\": { \"type\": \"string\" },\n                  \"title\": { \"type\": \"string\" },\n                  \"content\": { \"type\": \"string\" },\n                  \"comments\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                      \"type\": \"object\",\n                      \"required\": [\"id\", \"text\"],\n                      \"properties\": {\n                        \"id\": { \"type\": \"string\" },\n                        \"text\": { \"type\": \"string\" }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        { \"type\": \"null\" }\n      ]\n    }\n  }\n}",
        "language": "typescript"
      },
      "expected_effect": "Masks tokens that would create types not matching the GraphQL schema. Ensures user can be null (nullable in GraphQL), nested arrays are properly typed, and required fields are non-optional. Blocks missing nested types (Post, Comment) or incorrect nullability.",
      "valid_outputs": [
        "interface Comment {\n  id: string;\n  text: string;\n}\n\ninterface Post {\n  id: string;\n  title: string;\n  content?: string;\n  comments: Comment[];\n}\n\ninterface User {\n  id: string;\n  username: string;\n  email?: string;\n  posts: Post[];\n}\n\ninterface QueryResult {\n  user: User | null;\n}",
        "type Comment = {\n  id: string;\n  text: string;\n};\n\ntype Post = {\n  id: string;\n  title: string;\n  content?: string;\n  comments: Comment[];\n};\n\ntype User = {\n  id: string;\n  username: string;\n  email?: string;\n  posts: Post[];\n};\n\ntype QueryResult = {\n  user: User | null;\n};"
      ],
      "invalid_outputs": [
        "interface QueryResult {\n  user: User;\n}",
        "interface User {\n  id: string;\n  username: string;\n  posts: any[];\n}",
        "interface QueryResult {\n  user?: User;\n}"
      ],
      "tags": [
        "syntax",
        "graphql",
        "schema",
        "nested-types"
      ],
      "language": "typescript",
      "domain": "syntax"
    },
    {
      "id": "ts-conditional-001",
      "name": "Recursive Conditional Type Flattening",
      "description": "Recursively flatten nested array types to any depth",
      "scenario": "Developer implementing a DeepFlatten<T> utility type that recursively unwraps nested arrays to extract the innermost element type. For example: DeepFlatten<number[][][]> should yield number. This requires recursive conditional types with proper termination conditions.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "any",
            "scope": "type_parameter"
          }
        ],
        "expected_type": "DeepFlatten<T>",
        "type_aliases": {
          "DeepFlatten": "T extends Array<infer U> ? DeepFlatten<U> : T"
        }
      },
      "expected_effect": "Masks tokens that would create non-recursive or incorrectly recursive type definitions. Ensures the type recursively checks if T is an array, extracts the element type with 'infer U', and recursively applies DeepFlatten to U. Base case returns T when it's not an array.",
      "valid_outputs": [
        "type DeepFlatten<T> = T extends Array<infer U> ? DeepFlatten<U> : T;\n\n// Usage examples:\ntype Test1 = DeepFlatten<number[][][]>; // number\ntype Test2 = DeepFlatten<string[][]>; // string\ntype Test3 = DeepFlatten<boolean>; // boolean",
        "type DeepFlatten<T> = T extends (infer U)[] ? DeepFlatten<U> : T;\n\n// With readonly arrays:\ntype DeepFlattenReadonly<T> = T extends ReadonlyArray<infer U> ? DeepFlattenReadonly<U> : T;",
        "type DeepFlatten<T> = T extends Array<infer U>\n  ? U extends Array<any>\n    ? DeepFlatten<U>\n    : U\n  : T;"
      ],
      "invalid_outputs": [
        "type DeepFlatten<T> = T extends Array<infer U> ? U : T;",
        "type DeepFlatten<T> = T[number];",
        "type DeepFlatten<T> = T extends any[] ? T[0] : T;",
        "type DeepFlatten<T> = T;"
      ],
      "tags": [
        "types",
        "conditional",
        "recursive",
        "advanced",
        "utility-types"
      ],
      "language": "typescript",
      "domain": "types"
    },
    {
      "id": "ts-conditional-002",
      "name": "Template Literal Inference Pattern",
      "description": "Extract parts from template literal types using inference",
      "scenario": "Developer implementing a type that parses a route pattern string like '/users/:userId/posts/:postId' and extracts the parameter names as a union type 'userId' | 'postId'. This uses template literal types with recursive inference to extract all :param patterns.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "string",
            "scope": "type_parameter"
          }
        ],
        "expected_type": "ExtractRouteParams<T>",
        "type_aliases": {
          "ExtractRouteParams": "T extends `${infer _Start}:${infer Param}/${infer Rest}`\n  ? Param | ExtractRouteParams<`/${Rest}`>\n  : T extends `${infer _Start}:${infer Param}`\n  ? Param\n  : never"
        }
      },
      "expected_effect": "Masks tokens that would create non-recursive or incorrect template literal inference patterns. Ensures the type matches :param patterns, extracts the parameter name with 'infer Param', and recursively processes the rest of the string. Handles both intermediate and terminal parameters correctly.",
      "valid_outputs": [
        "type ExtractRouteParams<T extends string> =\n  T extends `${infer _Start}:${infer Param}/${infer Rest}`\n    ? Param | ExtractRouteParams<`/${Rest}`>\n    : T extends `${infer _Start}:${infer Param}`\n    ? Param\n    : never;\n\n// Usage:\ntype Params = ExtractRouteParams<'/users/:userId/posts/:postId'>; // 'userId' | 'postId'\ntype SingleParam = ExtractRouteParams<'/users/:id'>; // 'id'",
        "type ExtractRouteParams<T extends string> =\n  T extends `${string}:${infer Param}/${infer Rest}`\n    ? Param | ExtractRouteParams<Rest>\n    : T extends `${string}:${infer Param}`\n    ? Param\n    : never;",
        "type ExtractParam<T extends string> =\n  T extends `:${infer Param}` ? Param : never;\n\ntype SplitRoute<T extends string> =\n  T extends `${infer First}/${infer Rest}`\n    ? ExtractParam<First> | SplitRoute<Rest>\n    : ExtractParam<T>;\n\ntype ExtractRouteParams<T extends string> = SplitRoute<T>;"
      ],
      "invalid_outputs": [
        "type ExtractRouteParams<T extends string> = T extends `:${infer Param}` ? Param : never;",
        "type ExtractRouteParams<T extends string> = string;",
        "type ExtractRouteParams<T extends string> = T extends `${infer Param}` ? Param : never;",
        "type ExtractRouteParams<T extends string> = T;"
      ],
      "tags": [
        "types",
        "template-literals",
        "inference",
        "recursive",
        "parsing"
      ],
      "language": "typescript",
      "domain": "types"
    },
    {
      "id": "ts-conditional-003",
      "name": "Distributive Conditional Types",
      "description": "Apply conditional type distributively over union types",
      "scenario": "Developer implementing a ToArray<T> utility that wraps each member of a union type in an array. For example: ToArray<string | number> should yield string[] | number[], not (string | number)[]. This demonstrates how conditional types distribute over unions when T is a naked type parameter.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "any",
            "scope": "type_parameter"
          }
        ],
        "expected_type": "ToArray<T>",
        "type_aliases": {
          "ToArray": "T extends any ? T[] : never",
          "NonDistributive": "[T] extends [any] ? T[] : never"
        }
      },
      "expected_effect": "Masks tokens that would create non-distributive conditional types or incorrectly wrap union types. Ensures the naked type parameter T causes distribution over unions. Demonstrates the difference between distributive (T extends any) and non-distributive ([T] extends [any]) patterns.",
      "valid_outputs": [
        "type ToArray<T> = T extends any ? T[] : never;\n\n// Distributive behavior:\ntype Test1 = ToArray<string | number>; // string[] | number[]\ntype Test2 = ToArray<'a' | 'b' | 'c'>; // 'a'[] | 'b'[] | 'c'[]\n\n// Non-distributive for comparison:\ntype ToArrayNonDist<T> = [T] extends [any] ? T[] : never;\ntype Test3 = ToArrayNonDist<string | number>; // (string | number)[]",
        "type ToArray<T> = T extends infer U ? U[] : never;\n\n// With additional constraint:\ntype ToArrayIfNotNull<T> = T extends null ? never : T[];",
        "type ToArray<T> = T extends any ? Array<T> : never;\n\n// More complex distribution:\ntype WrapInPromise<T> = T extends any ? Promise<T> : never;\ntype Test = WrapInPromise<string | number>; // Promise<string> | Promise<number>"
      ],
      "invalid_outputs": [
        "type ToArray<T> = T[];",
        "type ToArray<T> = [T] extends [any] ? T[] : never;",
        "type ToArray<T> = Array<T>;",
        "type ToArray<T> = T extends any ? [T] : never;"
      ],
      "tags": [
        "types",
        "conditional",
        "distributive",
        "unions",
        "advanced"
      ],
      "language": "typescript",
      "domain": "types"
    },
    {
      "id": "ts-conditional-004",
      "name": "Mapped Types with Key Remapping",
      "description": "Transform object keys using template literals and conditional types",
      "scenario": "Developer creating a utility type that converts object properties to getter methods. For example: { name: string, age: number } becomes { getName: () => string, getAge: () => number }. Uses mapped types with 'as' clause for key remapping and template literals.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "object",
            "scope": "type_parameter"
          }
        ],
        "expected_type": "Getters<T>",
        "type_aliases": {
          "Getters": "{ [K in keyof T as `get${Capitalize<K & string>}`]: () => T[K] }"
        }
      },
      "expected_effect": "Masks tokens that would create mapped types without proper key remapping. Ensures keys are transformed using template literal type with Capitalize utility. Blocks patterns that don't use 'as' clause or don't properly constrain K to string (K & string).",
      "valid_outputs": [
        "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<K & string>}`]: () => T[K];\n};\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\ntype PersonGetters = Getters<Person>;\n// { getName: () => string; getAge: () => number; }",
        "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\n// With setters too:\ntype Accessors<T> = {\n  [K in keyof T as `get${Capitalize<K & string>}`]: () => T[K];\n} & {\n  [K in keyof T as `set${Capitalize<K & string>}`]: (value: T[K]) => void;\n};",
        "type Getters<T> = {\n  readonly [K in keyof T as K extends string ? `get${Capitalize<K>}` : never]: () => T[K];\n};"
      ],
      "invalid_outputs": [
        "type Getters<T> = {\n  [K in keyof T]: () => T[K];\n};",
        "type Getters<T> = {\n  [K in keyof T as `get${K}`]: () => T[K];\n};",
        "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<K>}`]: () => T[K];\n};",
        "type Getters<T> = {\n  [K in keyof T as string]: () => T[K];\n};"
      ],
      "tags": [
        "types",
        "mapped",
        "key-remapping",
        "template-literals",
        "advanced"
      ],
      "language": "typescript",
      "domain": "types"
    },
    {
      "id": "ts-conditional-005",
      "name": "Conditional Type with Constraint Inference",
      "description": "Extract constraint-respecting types using conditional inference",
      "scenario": "Developer implementing a GetRequired<T> utility that extracts only the required (non-optional) properties from an object type. For example: { a: string; b?: number; c: boolean } becomes { a: string; c: boolean }. This uses conditional types to test if a key is required.",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "object",
            "scope": "type_parameter"
          }
        ],
        "expected_type": "GetRequired<T>",
        "type_aliases": {
          "RequiredKeys": "{ [K in keyof T]-?: {} extends Pick<T, K> ? never : K }[keyof T]",
          "GetRequired": "Pick<T, RequiredKeys<T>>"
        }
      },
      "expected_effect": "Masks tokens that would create incorrect required key detection logic. Ensures the type uses the -? modifier to remove optionality temporarily, tests if {} extends Pick<T, K> to detect optional properties, and uses indexed access [keyof T] to extract the union of required keys.",
      "valid_outputs": [
        "type RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\ntype GetRequired<T> = Pick<T, RequiredKeys<T>>;\n\ninterface Example {\n  a: string;\n  b?: number;\n  c: boolean;\n}\n\ntype Required = GetRequired<Example>; // { a: string; c: boolean; }",
        "type GetRequired<T> = {\n  [K in keyof T as {} extends Pick<T, K> ? never : K]: T[K];\n};",
        "type RequiredKeys<T> = {\n  [K in keyof T]: T extends Record<K, T[K]> ? K : never;\n}[keyof T];\n\ntype GetRequired<T> = {\n  [K in RequiredKeys<T>]: T[K];\n};"
      ],
      "invalid_outputs": [
        "type GetRequired<T> = Required<T>;",
        "type GetRequired<T> = {\n  [K in keyof T]: T[K];\n};",
        "type GetRequired<T> = Pick<T, keyof T>;",
        "type GetRequired<T> = Omit<T, OptionalKeys<T>>;"
      ],
      "tags": [
        "types",
        "conditional",
        "utility-types",
        "inference",
        "advanced"
      ],
      "language": "typescript",
      "domain": "types"
    },
    {
      "id": "go-types-001",
      "name": "Interface Satisfaction - Implicit Implementation",
      "description": "Implement io.Reader interface without explicit declaration",
      "scenario": "Developer implementing a custom Reader type. In Go, interfaces are satisfied implicitly - the type must have Read(p []byte) (n int, err error) method with exact signature matching io.Reader.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "*CustomReader",
            "scope": "local"
          },
          {
            "name": "data",
            "type_expr": "[]byte",
            "scope": "local"
          }
        ],
        "expected_type": "io.Reader",
        "type_aliases": {
          "io.Reader": "interface { Read(p []byte) (n int, err error) }"
        },
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "n >= 0 && n <= len(p)",
            "scope": "Read",
            "variables": [
              "n",
              "p"
            ]
          },
          {
            "kind": "postcondition",
            "expression": "(n == 0) == (err != nil)",
            "scope": "Read",
            "variables": [
              "n",
              "err"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would create a Read method with wrong signature. Ensures exact match: Read(p []byte) (n int, err error). Blocks incorrect parameter types, return types, or method names.",
      "valid_outputs": [
        "func (r *CustomReader) Read(p []byte) (n int, err error) {\n\tn = copy(p, r.data)\n\tif n == 0 {\n\t\terr = io.EOF\n\t}\n\treturn\n}",
        "func (r *CustomReader) Read(p []byte) (int, error) {\n\tif len(r.data) == 0 {\n\t\treturn 0, io.EOF\n\t}\n\tn := copy(p, r.data)\n\tr.data = r.data[n:]\n\treturn n, nil\n}"
      ],
      "invalid_outputs": [
        "func (r *CustomReader) Read(p []byte) int { ... }",
        "func (r *CustomReader) Read(data []byte) (n int, err error) { ... }",
        "func (r *CustomReader) ReadData(p []byte) (int, error) { ... }",
        "func (r *CustomReader) Read(p string) (int, error) { ... }"
      ],
      "tags": [
        "types",
        "interfaces",
        "implicit",
        "io"
      ],
      "language": "go",
      "domain": "types"
    },
    {
      "id": "go-types-002",
      "name": "Channel Direction - Send vs Receive",
      "description": "Enforce channel direction constraints for type safety",
      "scenario": "Developer writing producer/consumer pattern with directional channels. Send-only channels (chan<- T) can only be written to, receive-only channels (<-chan T) can only be read from. This prevents misuse.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "out",
            "type_expr": "chan<- int",
            "scope": "parameter",
            "mutable": false
          },
          {
            "name": "in",
            "type_expr": "<-chan int",
            "scope": "parameter",
            "mutable": false
          }
        ],
        "function_signatures": [
          {
            "name": "producer",
            "params": [
              {
                "name": "out",
                "type_expr": "chan<- int"
              }
            ],
            "return_type": "void"
          },
          {
            "name": "consumer",
            "params": [
              {
                "name": "in",
                "type_expr": "<-chan int"
              }
            ],
            "return_type": "void"
          }
        ]
      },
      "expected_effect": "Masks tokens attempting to receive from send-only channel or send to receive-only channel. Ensures 'out <- value' for chan<- and 'value := <-in' for <-chan.",
      "valid_outputs": [
        "func producer(out chan<- int) {\n\tfor i := 0; i < 10; i++ {\n\t\tout <- i\n\t}\n\tclose(out)\n}",
        "func consumer(in <-chan int) {\n\tfor val := range in {\n\t\tfmt.Println(val)\n\t}\n}",
        "func consumer(in <-chan int) {\n\tselect {\n\tcase v := <-in:\n\t\tprocess(v)\n\tdefault:\n\t\treturn\n\t}\n}"
      ],
      "invalid_outputs": [
        "func producer(out chan<- int) { val := <-out }",
        "func consumer(in <-chan int) { in <- 42 }",
        "func producer(out chan<- int) { close(<-out) }"
      ],
      "tags": [
        "types",
        "channels",
        "concurrency",
        "direction"
      ],
      "language": "go",
      "domain": "types"
    },
    {
      "id": "go-types-003",
      "name": "Generic Constraints - comparable and any",
      "description": "Use Go 1.18+ generics with type parameter constraints",
      "scenario": "Developer writing generic functions with type constraints. 'comparable' constraint allows == and != operations. 'any' (interface{}) allows any type but no operations.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "T",
            "type_expr": "comparable",
            "scope": "type_parameter"
          },
          {
            "name": "slice",
            "type_expr": "[]T",
            "scope": "parameter"
          },
          {
            "name": "target",
            "type_expr": "T",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "Contains",
            "params": [
              {
                "name": "slice",
                "type_expr": "[]T"
              },
              {
                "name": "target",
                "type_expr": "T"
              }
            ],
            "return_type": "bool",
            "type_params": [
              "T"
            ]
          }
        ],
        "expected_type": "bool",
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "comparable(T)",
            "scope": "Contains",
            "variables": [
              "T"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that don't respect comparable constraint. Allows == and != on T values. Blocks operations requiring numeric constraints like < or + on generic T.",
      "valid_outputs": [
        "func Contains[T comparable](slice []T, target T) bool {\n\tfor _, item := range slice {\n\t\tif item == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
        "func Contains[T comparable](slice []T, target T) bool {\n\tfor i := 0; i < len(slice); i++ {\n\t\tif slice[i] == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"
      ],
      "invalid_outputs": [
        "func Contains[T any](slice []T, target T) bool { if slice[0] == target { ... } }",
        "func Contains[T comparable](slice []T, target T) bool { return slice[0] > target }",
        "func Contains(slice []interface{}, target interface{}) bool { return slice[0] == target }"
      ],
      "tags": [
        "types",
        "generics",
        "constraints",
        "comparable"
      ],
      "language": "go",
      "domain": "types"
    },
    {
      "id": "go-imports-001",
      "name": "Internal Package Path Restrictions",
      "description": "Enforce Go's internal package visibility rules",
      "scenario": "Developer importing packages in a Go project. Go's 'internal' package convention restricts imports: only code in the parent tree of the internal directory can import it. E.g., pkg/internal/util can only be imported by pkg/* packages, not by other top-level packages.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "available_modules": [
          "github.com/myapp/pkg/handlers",
          "github.com/myapp/pkg/internal/util",
          "github.com/other/project/pkg/public"
        ],
        "forbidden_imports": [
          "github.com/other/project/internal/secrets",
          "github.com/other/project/pkg/internal/util"
        ]
      },
      "expected_effect": "Masks import statements for external 'internal' packages. Allows imports from same-tree internal packages. Enforces Go's internal package visibility invariant.",
      "valid_outputs": [
        "import \"github.com/myapp/pkg/internal/util\"",
        "import (\n\t\"github.com/myapp/pkg/handlers\"\n\t\"github.com/myapp/pkg/internal/util\"\n)",
        "import \"github.com/other/project/pkg/public\""
      ],
      "invalid_outputs": [
        "import \"github.com/other/project/internal/secrets\"",
        "import \"github.com/other/project/pkg/internal/util\"",
        "import (\n\t\"fmt\"\n\t\"github.com/other/project/internal/secrets\"\n)"
      ],
      "tags": [
        "imports",
        "internal",
        "visibility",
        "packages"
      ],
      "language": "go",
      "domain": "imports"
    },
    {
      "id": "go-imports-002",
      "name": "Unsafe Package Blocking",
      "description": "Block unsafe package for memory-safe code generation",
      "scenario": "Developer writing production Go code where the 'unsafe' package is forbidden by policy. The unsafe package allows arbitrary pointer manipulation and breaks Go's type safety and memory safety guarantees. Code must not import or use unsafe.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "available_modules": [
          "context",
          "encoding/json",
          "fmt",
          "io",
          "sync"
        ],
        "forbidden_imports": [
          "unsafe"
        ]
      },
      "expected_effect": "Masks any import statement containing 'unsafe'. Blocks unsafe.Pointer, unsafe.Sizeof, and other unsafe operations. Ensures memory-safe code generation.",
      "valid_outputs": [
        "import \"fmt\"",
        "import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"sync\"\n)",
        "import (\n\t\"io\"\n\t\"fmt\"\n)"
      ],
      "invalid_outputs": [
        "import \"unsafe\"",
        "import (\n\t\"fmt\"\n\t\"unsafe\"\n)",
        "import u \"unsafe\"",
        "var _ = unsafe.Pointer(nil)"
      ],
      "tags": [
        "imports",
        "unsafe",
        "safety",
        "policy"
      ],
      "language": "go",
      "domain": "imports"
    },
    {
      "id": "go-imports-003",
      "name": "Standard Library Restrictions for Embedded",
      "description": "Restrict standard library imports for embedded/TinyGo targets",
      "scenario": "Developer writing Go code for TinyGo (embedded systems). Many standard library packages aren't available: net/http, os/exec, database/sql. Only core packages like fmt, sync, time (partial) are available.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "available_modules": [
          "fmt",
          "machine",
          "runtime/volatile",
          "sync",
          "time"
        ],
        "forbidden_imports": [
          "database/sql",
          "net/http",
          "net/http/httptest",
          "os/exec",
          "plugin",
          "reflect"
        ]
      },
      "expected_effect": "Masks imports of heavy standard library packages unavailable in embedded contexts. Allows core packages and TinyGo-specific packages. Enforces embedded environment constraints.",
      "valid_outputs": [
        "import \"fmt\"",
        "import \"machine\"",
        "import (\n\t\"fmt\"\n\t\"sync\"\n\t\"machine\"\n)",
        "import \"runtime/volatile\""
      ],
      "invalid_outputs": [
        "import \"net/http\"",
        "import \"database/sql\"",
        "import (\n\t\"fmt\"\n\t\"net/http\"\n)",
        "import \"os/exec\""
      ],
      "tags": [
        "imports",
        "embedded",
        "tinygo",
        "constraints"
      ],
      "language": "go",
      "domain": "imports"
    },
    {
      "id": "go-controlflow-001",
      "name": "Defer Ordering and Cleanup",
      "description": "Proper defer statement ordering for resource cleanup",
      "scenario": "Developer opening a file and must ensure it's closed via defer. Defer statements execute in LIFO order. The defer must come immediately after successful resource acquisition and before error checks that might cause early return.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "filename",
            "type_expr": "string",
            "scope": "parameter"
          },
          {
            "name": "f",
            "type_expr": "*os.File",
            "scope": "local"
          },
          {
            "name": "err",
            "type_expr": "error",
            "scope": "local"
          }
        ],
        "function_signatures": [
          {
            "name": "processFile",
            "params": [
              {
                "name": "filename",
                "type_expr": "string"
              }
            ],
            "return_type": "error"
          }
        ],
        "control_flow": {
          "function_name": "processFile",
          "expected_return_type": "error"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "defer comes before error-returning paths",
            "scope": "processFile"
          }
        ]
      },
      "expected_effect": "Masks control flow that doesn't properly defer cleanup. Ensures defer f.Close() appears after successful os.Open. Blocks patterns that skip cleanup on error paths.",
      "valid_outputs": [
        "func processFile(filename string) error {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\t// process file\n\treturn nil\n}",
        "func processFile(filename string) error {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"open: %w\", err)\n\t}\n\tdefer f.Close()\n\tdata, err := io.ReadAll(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn processData(data)\n}"
      ],
      "invalid_outputs": [
        "func processFile(filename string) error {\n\tf, _ := os.Open(filename)\n\t// missing defer\n\treturn nil\n}",
        "func processFile(filename string) error {\n\tf, err := os.Open(filename)\n\tdefer f.Close()\n\tif err != nil { return err }\n\t...\n}",
        "func processFile(filename string) error {\n\tf, err := os.Open(filename)\n\tif err == nil {\n\t\tf.Close()\n\t}\n\treturn err\n}"
      ],
      "tags": [
        "controlflow",
        "defer",
        "cleanup",
        "resources"
      ],
      "language": "go",
      "domain": "controlflow"
    },
    {
      "id": "go-controlflow-002",
      "name": "Goroutine Context with Select",
      "description": "Context-aware goroutine with select statement for cancellation",
      "scenario": "Developer writing a goroutine that must respect context cancellation. The select statement multiplexes on context.Done() and work channel. This is idiomatic Go for cancellable concurrent operations.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "ctx",
            "type_expr": "context.Context",
            "scope": "parameter"
          },
          {
            "name": "jobs",
            "type_expr": "<-chan Job",
            "scope": "parameter"
          },
          {
            "name": "results",
            "type_expr": "chan<- Result",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "worker",
            "params": [
              {
                "name": "ctx",
                "type_expr": "context.Context"
              },
              {
                "name": "jobs",
                "type_expr": "<-chan Job"
              },
              {
                "name": "results",
                "type_expr": "chan<- Result"
              }
            ],
            "return_type": "void"
          }
        ],
        "control_flow": {
          "function_name": "worker",
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "select must include case <-ctx.Done()",
            "scope": "worker"
          }
        ]
      },
      "expected_effect": "Masks control flow missing context cancellation handling. Ensures select has case <-ctx.Done() alongside work channel. Enforces graceful shutdown pattern.",
      "valid_outputs": [
        "func worker(ctx context.Context, jobs <-chan Job, results chan<- Result) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase job := <-jobs:\n\t\t\tresult := process(job)\n\t\t\tresults <- result\n\t\t}\n\t}\n}",
        "func worker(ctx context.Context, jobs <-chan Job, results chan<- Result) {\n\tfor {\n\t\tselect {\n\t\tcase job, ok := <-jobs:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- process(job)\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}"
      ],
      "invalid_outputs": [
        "func worker(ctx context.Context, jobs <-chan Job, results chan<- Result) {\n\tfor job := range jobs {\n\t\tresults <- process(job)\n\t}\n}",
        "func worker(ctx context.Context, jobs <-chan Job, results chan<- Result) {\n\tfor {\n\t\tjob := <-jobs\n\t\tresults <- process(job)\n\t}\n}",
        "func worker(ctx context.Context, jobs <-chan Job, results chan<- Result) {\n\tselect {\n\tcase job := <-jobs:\n\t\tresults <- process(job)\n\t}\n}"
      ],
      "tags": [
        "controlflow",
        "context",
        "goroutines",
        "select"
      ],
      "language": "go",
      "domain": "controlflow"
    },
    {
      "id": "go-controlflow-003",
      "name": "Error Return Pattern - nil Check",
      "description": "Idiomatic error handling with if err != nil pattern",
      "scenario": "Developer calling a function that returns (T, error) and must check error before using result. Go idiom: check err != nil immediately, handle error, then use result. Never ignore errors.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "id",
            "type_expr": "int",
            "scope": "parameter"
          },
          {
            "name": "user",
            "type_expr": "*User",
            "scope": "local"
          },
          {
            "name": "err",
            "type_expr": "error",
            "scope": "local"
          }
        ],
        "function_signatures": [
          {
            "name": "fetchUser",
            "params": [
              {
                "name": "id",
                "type_expr": "int"
              }
            ],
            "return_type": "(*User, error)"
          }
        ],
        "control_flow": {
          "function_name": "fetchUser",
          "expected_return_type": "(*User, error)"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "if err != nil { return nil, err }",
            "scope": "fetchUser"
          },
          {
            "kind": "postcondition",
            "expression": "(user == nil) != (err == nil)",
            "scope": "fetchUser",
            "variables": [
              "user",
              "err"
            ]
          }
        ]
      },
      "expected_effect": "Masks control flow that doesn't check errors. Ensures if err != nil pattern appears before result usage. Blocks patterns that ignore error returns.",
      "valid_outputs": [
        "func fetchUser(id int) (*User, error) {\n\tuser, err := db.Query(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}",
        "func fetchUser(id int) (*User, error) {\n\tuser, err := db.Query(id)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fetch user %d: %w\", id, err)\n\t}\n\tif user == nil {\n\t\treturn nil, ErrNotFound\n\t}\n\treturn user, nil\n}"
      ],
      "invalid_outputs": [
        "func fetchUser(id int) (*User, error) {\n\tuser, _ := db.Query(id)\n\treturn user, nil\n}",
        "func fetchUser(id int) (*User, error) {\n\tuser, err := db.Query(id)\n\treturn user, err\n}",
        "func fetchUser(id int) (*User, error) {\n\tuser, err := db.Query(id)\n\tif user != nil {\n\t\treturn user, nil\n\t}\n\treturn nil, err\n}"
      ],
      "tags": [
        "controlflow",
        "errors",
        "nil-check",
        "idioms"
      ],
      "language": "go",
      "domain": "controlflow"
    },
    {
      "id": "go-semantics-001",
      "name": "Nil Check Before Pointer Dereference",
      "description": "Require nil check before dereferencing pointers or calling methods",
      "scenario": "Developer working with pointer types in Go. Before dereferencing or calling methods on a pointer, must verify it's not nil to avoid panic. This is a critical safety invariant in Go.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "user",
            "type_expr": "*User",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "processUser",
            "params": [
              {
                "name": "user",
                "type_expr": "*User"
              }
            ],
            "return_type": "error"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "user != nil before user.Method() or user.Field",
            "scope": "processUser",
            "variables": [
              "user"
            ]
          }
        ]
      },
      "expected_effect": "Masks code that dereferences pointers without nil checks. Requires if user == nil check or guard before access. Prevents nil pointer dereference panics.",
      "valid_outputs": [
        "func processUser(user *User) error {\n\tif user == nil {\n\t\treturn errors.New(\"user is nil\")\n\t}\n\treturn user.Validate()\n}",
        "func processUser(user *User) error {\n\tif user == nil {\n\t\treturn ErrNilUser\n\t}\n\tfmt.Println(user.Name)\n\treturn nil\n}",
        "func processUser(user *User) error {\n\tif user != nil {\n\t\treturn user.Save()\n\t}\n\treturn nil\n}"
      ],
      "invalid_outputs": [
        "func processUser(user *User) error {\n\treturn user.Validate()\n}",
        "func processUser(user *User) error {\n\tfmt.Println(user.Name)\n\treturn nil\n}",
        "func processUser(user *User) error {\n\tif user.ID > 0 {\n\t\treturn nil\n\t}\n\treturn errors.New(\"invalid\")\n}"
      ],
      "tags": [
        "semantics",
        "nil-check",
        "pointers",
        "safety"
      ],
      "language": "go",
      "domain": "semantics"
    },
    {
      "id": "go-semantics-002",
      "name": "Context Propagation - First Parameter",
      "description": "Enforce context.Context as first parameter convention",
      "scenario": "Developer writing functions that perform I/O, call services, or can be cancelled. Go convention: context.Context must be the first parameter (except for receiver). This enables cancellation and deadline propagation throughout the call chain.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "ctx",
            "type_expr": "context.Context",
            "scope": "parameter",
            "mutable": false
          },
          {
            "name": "userID",
            "type_expr": "string",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "fetchUserData",
            "params": [
              {
                "name": "ctx",
                "type_expr": "context.Context"
              },
              {
                "name": "userID",
                "type_expr": "string"
              }
            ],
            "return_type": "(*UserData, error)"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "ctx is first parameter in all I/O functions",
            "scope": "fetchUserData"
          },
          {
            "kind": "precondition",
            "expression": "ctx != nil",
            "scope": "fetchUserData",
            "variables": [
              "ctx"
            ]
          }
        ]
      },
      "expected_effect": "Masks function signatures with context.Context not as first parameter. Ensures context is available for cancellation checks. Enforces Go API design guidelines.",
      "valid_outputs": [
        "func fetchUserData(ctx context.Context, userID string) (*UserData, error) {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\treturn db.Get(ctx, userID)\n}",
        "func (s *Service) fetchUserData(ctx context.Context, userID string) (*UserData, error) {\n\treturn s.client.Fetch(ctx, userID)\n}"
      ],
      "invalid_outputs": [
        "func fetchUserData(userID string, ctx context.Context) (*UserData, error) { ... }",
        "func fetchUserData(userID string) (*UserData, error) { ... }",
        "func fetchUserData(ctx context.Context) (*UserData, error) { ... }"
      ],
      "tags": [
        "semantics",
        "context",
        "conventions",
        "api-design"
      ],
      "language": "go",
      "domain": "semantics"
    },
    {
      "id": "go-semantics-003",
      "name": "Resource Cleanup with Defer",
      "description": "Ensure defer is used for resource cleanup",
      "scenario": "Developer acquiring resources (files, locks, connections) must use defer to ensure cleanup happens even if function panics or returns early. Defer guarantees cleanup runs in all exit paths.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "mu",
            "type_expr": "*sync.Mutex",
            "scope": "local"
          },
          {
            "name": "conn",
            "type_expr": "*sql.DB",
            "scope": "local"
          },
          {
            "name": "file",
            "type_expr": "*os.File",
            "scope": "local"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "resource.Acquire() followed by defer resource.Release()",
            "scope": "critical_section"
          },
          {
            "kind": "postcondition",
            "expression": "cleanup happens in all exit paths",
            "scope": "critical_section"
          }
        ]
      },
      "expected_effect": "Masks resource usage patterns without defer cleanup. Requires defer after successful resource acquisition. Prevents resource leaks.",
      "valid_outputs": [
        "func critical_section() error {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\t// critical work\n\treturn nil\n}",
        "func queryDB() (*Result, error) {\n\tconn, err := sql.Open(\"postgres\", dsn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\treturn conn.Query(query)\n}",
        "func readFile(path string) ([]byte, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\treturn io.ReadAll(file)\n}"
      ],
      "invalid_outputs": [
        "func critical_section() error {\n\tmu.Lock()\n\t// work\n\tmu.Unlock()\n\treturn nil\n}",
        "func queryDB() (*Result, error) {\n\tconn, _ := sql.Open(\"postgres\", dsn)\n\tres := conn.Query(query)\n\tconn.Close()\n\treturn res, nil\n}",
        "func readFile(path string) ([]byte, error) {\n\tfile, _ := os.Open(path)\n\treturn io.ReadAll(file)\n}"
      ],
      "tags": [
        "semantics",
        "defer",
        "cleanup",
        "resources"
      ],
      "language": "go",
      "domain": "semantics"
    },
    {
      "id": "go-syntax-001",
      "name": "Protobuf Struct Tags Schema",
      "description": "Validate protobuf struct tag syntax and field numbering",
      "scenario": "Developer writing Go structs with protobuf tags for code generation. Tags must follow exact syntax: `protobuf:\"type,number,opt,name=fieldname\"`. Field numbers must be unique and in range 1-536870911 (excluding 19000-19999).",
      "spec": {
        "version": "1.0",
        "regex": "`protobuf:\"[a-z0-9]+,[1-9][0-9]*,(opt|req|rep)(,name=[a-zA-Z_][a-zA-Z0-9_]*)?(,json=[a-zA-Z_][a-zA-Z0-9_]*)?\"`",
        "language": "go"
      },
      "expected_effect": "Masks struct tags not matching protobuf format. Ensures proper type,number,label format. Validates field numbers and options.",
      "valid_outputs": [
        "type User struct {\n\tID int64 `protobuf:\"varint,1,opt,name=id\"`\n\tName string `protobuf:\"bytes,2,opt,name=name\"`\n}",
        "type Request struct {\n\tUserIDs []int64 `protobuf:\"varint,1,rep,name=user_ids,json=userIds\"`\n}",
        "type Message struct {\n\tPayload []byte `protobuf:\"bytes,5,req,name=payload\"`\n}"
      ],
      "invalid_outputs": [
        "type User struct {\n\tID int64 `protobuf:\"varint,0,opt\"`\n}",
        "type User struct {\n\tID int64 `protobuf:\"varint 1 opt\"`\n}",
        "type User struct {\n\tName string `protobuf:\"bytes,2\"`\n}",
        "type User struct {\n\tID int64 `proto:\"varint,1,opt\"`\n}"
      ],
      "tags": [
        "syntax",
        "protobuf",
        "struct-tags",
        "validation"
      ],
      "language": "go",
      "domain": "syntax"
    },
    {
      "id": "go-syntax-002",
      "name": "Import Path Regex Validation",
      "description": "Validate Go import path format and constraints",
      "scenario": "Developer writing import statements. Go import paths must be valid: no uppercase in domain, alphanumeric with limited special chars, proper domain format for remote packages. Examples: \"fmt\", \"encoding/json\", \"github.com/user/repo/pkg\".",
      "spec": {
        "version": "1.0",
        "regex": "^\"([a-z0-9]+(/[a-z0-9_-]+)*|[a-z0-9.-]+\\.[a-z]{2,}/[a-zA-Z0-9_/-]+)\"$",
        "language": "go"
      },
      "expected_effect": "Masks import paths with invalid characters or format. Ensures lowercase domains, valid path separators. Blocks malformed or non-standard import paths.",
      "valid_outputs": [
        "\"fmt\"",
        "\"encoding/json\"",
        "\"github.com/gorilla/mux\"",
        "\"github.com/user/repo/internal/pkg\"",
        "\"golang.org/x/net/context\"",
        "\"google.golang.org/grpc\""
      ],
      "invalid_outputs": [
        "\"GitHub.com/user/repo\"",
        "\"fmt \"",
        "\"encoding\\json\"",
        "\"my package\"",
        "\"../relative/path\"",
        "\"C:\\windows\\path\""
      ],
      "tags": [
        "syntax",
        "imports",
        "regex",
        "validation"
      ],
      "language": "go",
      "domain": "syntax"
    },
    {
      "id": "go-syntax-003",
      "name": "Template Syntax for text/template",
      "description": "Validate Go template action syntax",
      "scenario": "Developer writing Go templates using text/template or html/template. Template actions use {{...}} delimiters with specific syntax: {{.Field}}, {{if .Cond}}...{{end}}, {{range .Items}}...{{end}}, {{template \"name\" .}}.",
      "spec": {
        "version": "1.0",
        "regex": "\\{\\{[\\s]*(-[\\s]*)?(\\.|[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*)[\\s]*(-[\\s]*)?\\}\\}|\\{\\{[\\s]*-?[\\s]*(if|range|with|block|template|define|end)[\\s]+[^}]+[\\s]*-?[\\s]*\\}\\}",
        "language": "go"
      },
      "expected_effect": "Masks template syntax errors in Go templates. Ensures proper {{action}} delimiter usage. Validates control structures and variable references.",
      "valid_outputs": [
        "tmpl := `Hello {{.Name}}!`",
        "tmpl := `{{if .Active}}Enabled{{else}}Disabled{{end}}`",
        "tmpl := `{{range .Items}}{{.Title}} {{end}}`",
        "tmpl := `{{template \"header\" .}} {{.Content}}`",
        "tmpl := `{{- .Field -}}`"
      ],
      "invalid_outputs": [
        "tmpl := `Hello {.Name}!`",
        "tmpl := `{{if .Active}}`",
        "tmpl := `{{ .Invalid Field }}`",
        "tmpl := `{{.}}`",
        "tmpl := `{{.Field}`"
      ],
      "tags": [
        "syntax",
        "templates",
        "regex",
        "text-template"
      ],
      "language": "go",
      "domain": "syntax"
    },
    {
      "id": "go-interfaces-001",
      "name": "Interface Embedding and Composition",
      "description": "Compose interfaces through embedding",
      "scenario": "Developer creating ReadWriteCloser interface by embedding io.Reader, io.Writer, and io.Closer. Go allows interface composition through embedding, creating a new interface with combined method sets.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "expected_type": "io.ReadWriteCloser",
        "type_aliases": {
          "io.Reader": "interface { Read(p []byte) (n int, err error) }",
          "io.Writer": "interface { Write(p []byte) (n int, err error) }",
          "io.Closer": "interface { Close() error }",
          "io.ReadWriteCloser": "interface { io.Reader; io.Writer; io.Closer }"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "type implements all embedded interface methods",
            "scope": "ReadWriteCloser"
          }
        ]
      },
      "expected_effect": "Masks implementations missing any of the three required methods. Ensures Read, Write, and Close methods all have correct signatures. Validates interface composition through embedding.",
      "valid_outputs": [
        "type File struct {\n\tf *os.File\n}\n\nfunc (f *File) Read(p []byte) (int, error) {\n\treturn f.f.Read(p)\n}\n\nfunc (f *File) Write(p []byte) (int, error) {\n\treturn f.f.Write(p)\n}\n\nfunc (f *File) Close() error {\n\treturn f.f.Close()\n}",
        "type BufferedConn struct {\n\tconn net.Conn\n\tbuf []byte\n}\n\nfunc (b *BufferedConn) Read(p []byte) (int, error) { /* ... */ }\nfunc (b *BufferedConn) Write(p []byte) (int, error) { /* ... */ }\nfunc (b *BufferedConn) Close() error { return b.conn.Close() }"
      ],
      "invalid_outputs": [
        "type File struct { f *os.File }\nfunc (f *File) Read(p []byte) (int, error) { ... }\nfunc (f *File) Write(p []byte) (int, error) { ... }",
        "type File struct { f *os.File }\nfunc (f File) Read(p []byte) (int, error) { ... }",
        "type File struct { f *os.File }\nfunc (f *File) ReadData(p []byte) (int, error) { ... }"
      ],
      "tags": [
        "interfaces",
        "embedding",
        "composition",
        "io"
      ],
      "language": "go",
      "domain": "types"
    },
    {
      "id": "go-interfaces-002",
      "name": "Empty Interface and Type Assertions",
      "description": "Type assertions and type switches with interface{}/any",
      "scenario": "Developer working with interface{} (or 'any' in Go 1.18+) and using type assertions to extract concrete types. Type assertion syntax: value.(Type) for single type, value.(type) in switch for multiple types.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "val",
            "type_expr": "interface{}",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "processValue",
            "params": [
              {
                "name": "val",
                "type_expr": "interface{}"
              }
            ],
            "return_type": "string"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "type assertion checked or in switch",
            "scope": "processValue",
            "variables": [
              "val"
            ]
          }
        ]
      },
      "expected_effect": "Masks unsafe type assertions without checks. Requires either comma-ok idiom (v, ok := val.(Type)) or type switch. Prevents runtime panics from failed assertions.",
      "valid_outputs": [
        "func processValue(val interface{}) string {\n\tswitch v := val.(type) {\n\tcase string:\n\t\treturn v\n\tcase int:\n\t\treturn strconv.Itoa(v)\n\tdefault:\n\t\treturn fmt.Sprintf(\"%v\", v)\n\t}\n}",
        "func processValue(val interface{}) string {\n\tif s, ok := val.(string); ok {\n\t\treturn s\n\t}\n\tif i, ok := val.(int); ok {\n\t\treturn strconv.Itoa(i)\n\t}\n\treturn \"unknown\"\n}",
        "func processValue(val interface{}) string {\n\tv, ok := val.(string)\n\tif !ok {\n\t\treturn \"not a string\"\n\t}\n\treturn v\n}"
      ],
      "invalid_outputs": [
        "func processValue(val interface{}) string {\n\treturn val.(string)\n}",
        "func processValue(val interface{}) string {\n\ts := val.(string)\n\treturn s\n}",
        "func processValue(val interface{}) string {\n\tswitch val.(type) {\n\tcase string:\n\t\treturn val.(string)\n\t}\n}"
      ],
      "tags": [
        "interfaces",
        "type-assertions",
        "type-switches",
        "any"
      ],
      "language": "go",
      "domain": "types"
    },
    {
      "id": "go-interfaces-003",
      "name": "Reader/Writer Interface Patterns",
      "description": "Implement standard library io.Reader and io.Writer patterns",
      "scenario": "Developer implementing custom io.Reader and io.Writer for streaming data processing. These are foundational interfaces in Go. Reader: Read(p []byte) (n int, err error) must return bytes read and error. Writer: Write(p []byte) (n int, err error) must return bytes written. Both have specific contracts about n and err values.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "buf",
            "type_expr": "[]byte",
            "scope": "local"
          }
        ],
        "type_aliases": {
          "io.Reader": "interface { Read(p []byte) (n int, err error) }",
          "io.Writer": "interface { Write(p []byte) (n int, err error) }"
        },
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "0 <= n <= len(p)",
            "scope": "Read",
            "variables": [
              "n",
              "p"
            ]
          },
          {
            "kind": "postcondition",
            "expression": "n < len(p) implies err != nil",
            "scope": "Read",
            "variables": [
              "n",
              "p",
              "err"
            ]
          },
          {
            "kind": "postcondition",
            "expression": "err == io.EOF or err == nil or n > 0",
            "scope": "Read",
            "variables": [
              "err",
              "n"
            ]
          }
        ]
      },
      "expected_effect": "Masks Reader/Writer implementations violating io contracts. Ensures n is in valid range [0, len(p)]. Enforces error semantics: n < len(p) means err must be set.",
      "valid_outputs": [
        "type ByteReader struct {\n\tdata []byte\n\tpos int\n}\n\nfunc (r *ByteReader) Read(p []byte) (n int, err error) {\n\tif r.pos >= len(r.data) {\n\t\treturn 0, io.EOF\n\t}\n\tn = copy(p, r.data[r.pos:])\n\tr.pos += n\n\tif r.pos >= len(r.data) {\n\t\terr = io.EOF\n\t}\n\treturn\n}",
        "type ByteWriter struct {\n\tbuf []byte\n}\n\nfunc (w *ByteWriter) Write(p []byte) (n int, err error) {\n\tw.buf = append(w.buf, p...)\n\treturn len(p), nil\n}"
      ],
      "invalid_outputs": [
        "func (r *ByteReader) Read(p []byte) (int, error) {\n\treturn len(r.data), nil\n}",
        "func (r *ByteReader) Read(p []byte) (int, error) {\n\tif r.pos >= len(r.data) {\n\t\treturn 0, nil\n\t}\n\treturn copy(p, r.data[r.pos:]), nil\n}",
        "func (r *ByteReader) Read(p []byte) (int, error) {\n\treturn -1, io.EOF\n}"
      ],
      "tags": [
        "interfaces",
        "io",
        "reader",
        "writer",
        "contracts"
      ],
      "language": "go",
      "domain": "types"
    },
    {
      "id": "go-interfaces-004",
      "name": "Method Set - Pointer vs Value Receivers",
      "description": "Understand method sets for pointer vs value types",
      "scenario": "Developer implementing an interface where method set differs between *T and T. A type T's method set includes only value receiver methods. A type *T's method set includes both value and pointer receiver methods. This affects interface satisfaction.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "*Counter",
            "scope": "local"
          }
        ],
        "type_aliases": {
          "Incrementer": "interface { Increment() }"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "Increment() modifies receiver, requires pointer",
            "scope": "Counter"
          }
        ]
      },
      "expected_effect": "Masks value receiver implementation for methods that modify state. Requires pointer receiver for mutating methods. Ensures correct method set for interface satisfaction.",
      "valid_outputs": [
        "type Counter struct {\n\tvalue int\n}\n\nfunc (c *Counter) Increment() {\n\tc.value++\n}",
        "type Counter struct {\n\tcount int\n}\n\nfunc (c *Counter) Increment() {\n\tc.count += 1\n}\n\nfunc (c Counter) Value() int {\n\treturn c.count\n}"
      ],
      "invalid_outputs": [
        "func (c Counter) Increment() {\n\tc.value++\n}",
        "type Counter int\nfunc (c Counter) Increment() { c++ }"
      ],
      "tags": [
        "interfaces",
        "method-sets",
        "receivers",
        "pointers"
      ],
      "language": "go",
      "domain": "types"
    },
    {
      "id": "go-interfaces-005",
      "name": "Interface Nil Check Subtlety",
      "description": "Handle nil interface vs nil concrete value distinction",
      "scenario": "Developer checking if interface is nil. In Go, an interface value is nil only if both type and value are nil. An interface holding a nil pointer of a concrete type is NOT nil. This is a common gotcha.",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "err",
            "type_expr": "error",
            "scope": "local"
          },
          {
            "name": "val",
            "type_expr": "interface{}",
            "scope": "local"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "interface is nil iff both type and value are nil",
            "scope": "checkNil"
          }
        ]
      },
      "expected_effect": "Masks incorrect nil checks on interfaces. Requires understanding that interface != nil can be true even if concrete value is nil. Shows correct checking patterns.",
      "valid_outputs": [
        "func checkError(err error) bool {\n\tif err != nil {\n\t\treturn true\n\t}\n\treturn false\n}",
        "func isNil(val interface{}) bool {\n\treturn val == nil\n}",
        "func returnError() error {\n\tvar err *MyError = nil\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
      ],
      "invalid_outputs": [
        "func returnError() error {\n\tvar err *MyError = nil\n\treturn err\n}",
        "func checkNil(val interface{}) bool {\n\tif v, ok := val.(*Type); ok {\n\t\treturn v == nil\n\t}\n\treturn false\n}"
      ],
      "tags": [
        "interfaces",
        "nil",
        "gotchas",
        "error-handling"
      ],
      "language": "go",
      "domain": "semantics"
    },
    {
      "id": "kt-types-001",
      "name": "Nullable Type Safe Navigation",
      "description": "Use safe call operator ?. with nullable types",
      "scenario": "Developer working with a nullable User? type and needing to safely access properties. Kotlin's type system requires using safe call operators (?.) or Elvis operator (?:) when working with nullable types. Direct property access on nullable types is a compile error.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "user",
            "type_expr": "User?",
            "scope": "local"
          }
        ],
        "class_definitions": [
          {
            "name": "User",
            "instance_vars": [
              {
                "name": "name",
                "type_expr": "String"
              },
              {
                "name": "email",
                "type_expr": "String"
              },
              {
                "name": "age",
                "type_expr": "Int"
              }
            ]
          }
        ],
        "expected_type": "String?"
      },
      "expected_effect": "Masks tokens that attempt direct property access on nullable types. Blocks 'user.name' (unsafe) and allows 'user?.name' (safe call), 'user!!.name' (non-null assertion), or 'user?.name ?: default' (Elvis). Enforces Kotlin's null safety at the token level.",
      "valid_outputs": [
        "user?.name",
        "user?.email ?: \"unknown\"",
        "user?.let { it.name }",
        "user?.name?.uppercase()"
      ],
      "invalid_outputs": [
        "user.name",
        "user.email",
        "user.age.toString()"
      ],
      "tags": [
        "types",
        "nullable",
        "null-safety",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "types"
    },
    {
      "id": "kt-types-002",
      "name": "Sealed Class Exhaustive When",
      "description": "Enforce exhaustive when expression with sealed classes",
      "scenario": "Developer implementing a when expression on a sealed class hierarchy. Kotlin's type system requires exhaustive coverage of all sealed class subtypes in when expressions used as expressions (not statements). Missing a branch causes a compile error.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "result",
            "type_expr": "Result",
            "scope": "local"
          }
        ],
        "class_definitions": [
          {
            "name": "Result",
            "bases": [
              "sealed class"
            ]
          },
          {
            "name": "Success",
            "bases": [
              "Result"
            ],
            "instance_vars": [
              {
                "name": "data",
                "type_expr": "String"
              }
            ]
          },
          {
            "name": "Error",
            "bases": [
              "Result"
            ],
            "instance_vars": [
              {
                "name": "message",
                "type_expr": "String"
              }
            ]
          },
          {
            "name": "Loading",
            "bases": [
              "Result"
            ]
          }
        ],
        "expected_type": "String"
      },
      "expected_effect": "Masks tokens that create non-exhaustive when expressions. Requires all sealed class subtypes (Success, Error, Loading) to be handled. Blocks when expressions missing branches or using 'else' prematurely.",
      "valid_outputs": [
        "when (result) {\n                is Success -> result.data\n                is Error -> result.message\n                is Loading -> \"Loading...\"\n            }",
        "when (result) {\n                is Success -> \"Got: ${result.data}\"\n                is Error -> \"Failed: ${result.message}\"\n                is Loading -> \"Please wait\"\n            }"
      ],
      "invalid_outputs": [
        "when (result) {\n                is Success -> result.data\n                is Error -> result.message\n            }",
        "when (result) {\n                is Success -> result.data\n            }",
        "result.data"
      ],
      "tags": [
        "types",
        "sealed-class",
        "when-expression",
        "exhaustiveness",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "types"
    },
    {
      "id": "kt-types-003",
      "name": "Suspend Function Context",
      "description": "Enforce suspend context requirements",
      "scenario": "Developer calling a suspend function which can only be called from coroutine contexts (other suspend functions, coroutine builders). Kotlin enforces that suspend functions cannot be called from regular synchronous contexts - this is a compile-time error.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "userId",
            "type_expr": "String",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "fetchUser",
            "params": [
              {
                "name": "id",
                "type_expr": "String"
              }
            ],
            "return_type": "User",
            "is_async": true
          },
          {
            "name": "processUser",
            "params": [
              {
                "name": "userId",
                "type_expr": "String"
              }
            ],
            "return_type": "User",
            "is_async": true
          }
        ],
        "expected_type": "User"
      },
      "expected_effect": "Masks tokens that call suspend functions without proper context. Allows direct suspend function calls when inside a suspend function. Blocks direct calls from non-suspend contexts; requires coroutine builders like runBlocking, launch, async.",
      "valid_outputs": [
        "return fetchUser(userId)",
        "val user = fetchUser(userId)\nreturn user",
        "return fetchUser(userId).also { println(it) }"
      ],
      "invalid_outputs": [
        "Thread { fetchUser(userId) }.start()",
        "val handler = Handler()\nhandler.post { fetchUser(userId) }",
        "object : Runnable { override fun run() = fetchUser(userId) }"
      ],
      "tags": [
        "types",
        "suspend",
        "coroutines",
        "async",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "types"
    },
    {
      "id": "kt-imports-001",
      "name": "Platform-Specific Imports (JVM vs JS vs Native)",
      "description": "Enforce platform-specific import availability",
      "scenario": "Developer writing multiplatform Kotlin code that uses platform-specific APIs. On JVM, java.util.* is available. On JS, kotlin.js.* is available. On Native, kotlinx.cinterop.* is available. Using the wrong platform API causes compilation errors in multiplatform projects.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "available_modules": [
          "java.io",
          "java.time",
          "java.util",
          "kotlin.collections",
          "kotlin.text",
          "kotlinx.coroutines",
          "kotlinx.coroutines.flow"
        ],
        "forbidden_imports": [
          "kotlin.js",
          "kotlinx.cinterop",
          "platform.posix"
        ]
      },
      "expected_effect": "Masks import tokens for platform-specific modules not available on the target platform. Allows JVM imports (java.*) but blocks JS (kotlin.js.*) and Native (kotlinx.cinterop.*) imports.",
      "valid_outputs": [
        "import java.util.UUID",
        "import java.time.Instant",
        "import kotlinx.coroutines.flow.Flow",
        "import kotlin.collections.List"
      ],
      "invalid_outputs": [
        "import kotlin.js.Date",
        "import kotlinx.cinterop.CPointer",
        "import platform.posix.getpid"
      ],
      "tags": [
        "imports",
        "multiplatform",
        "jvm",
        "js",
        "native",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "imports"
    },
    {
      "id": "kt-imports-002",
      "name": "Coroutine Scope Requirements",
      "description": "Enforce kotlinx.coroutines imports for suspend functions",
      "scenario": "Developer using coroutines features (Flow, CoroutineScope, launch, etc.) which require kotlinx.coroutines imports. Without the proper imports, coroutine builders and Flow operators are unresolved references.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "available_modules": [
          "kotlin.coroutines",
          "kotlinx.coroutines",
          "kotlinx.coroutines.flow"
        ],
        "module_stubs": {
          "kotlinx.coroutines": {
            "module_name": "kotlinx.coroutines",
            "exports": {
              "CoroutineScope": "interface",
              "launch": "function",
              "async": "function",
              "runBlocking": "function",
              "Dispatchers": "object"
            }
          },
          "kotlinx.coroutines.flow": {
            "module_name": "kotlinx.coroutines.flow",
            "exports": {
              "Flow": "interface",
              "flow": "function",
              "collect": "extension",
              "map": "extension",
              "filter": "extension"
            }
          }
        }
      },
      "expected_effect": "Masks tokens that use coroutine APIs without importing them. Requires 'import kotlinx.coroutines.flow.Flow' before using Flow, 'import kotlinx.coroutines.launch' before using launch, etc.",
      "valid_outputs": [
        "import kotlinx.coroutines.flow.Flow",
        "import kotlinx.coroutines.flow.map",
        "import kotlinx.coroutines.CoroutineScope",
        "import kotlinx.coroutines.*"
      ],
      "invalid_outputs": [
        "import java.util.concurrent.Flow",
        "import reactor.core.publisher.Flux"
      ],
      "tags": [
        "imports",
        "coroutines",
        "flow",
        "async",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "imports"
    },
    {
      "id": "kt-imports-003",
      "name": "Annotation Processing Imports",
      "description": "Enforce annotation processor imports (Room, Serialization, etc.)",
      "scenario": "Developer using kotlinx.serialization with @Serializable annotation which requires specific imports. Annotation processors like Room, Serialization, Parcelize generate code that depends on correct imports being present.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "imports": [
          {
            "module": "kotlinx.serialization",
            "name": "Serializable"
          }
        ],
        "available_modules": [
          "kotlinx.serialization",
          "kotlinx.serialization.Serializable",
          "kotlinx.serialization.json"
        ],
        "module_stubs": {
          "kotlinx.serialization": {
            "module_name": "kotlinx.serialization",
            "exports": {
              "Serializable": "annotation class",
              "SerialName": "annotation class",
              "Transient": "annotation class"
            }
          },
          "kotlinx.serialization.json": {
            "module_name": "kotlinx.serialization.json",
            "exports": {
              "Json": "object",
              "encodeToString": "function",
              "decodeFromString": "function"
            }
          }
        }
      },
      "expected_effect": "Masks tokens that use serialization annotations without proper imports. Requires '@Serializable' to have 'import kotlinx.serialization.Serializable'. Enforces that annotation processor requirements are met.",
      "valid_outputs": [
        "import kotlinx.serialization.Serializable",
        "import kotlinx.serialization.SerialName",
        "import kotlinx.serialization.json.Json"
      ],
      "invalid_outputs": [
        "import com.google.gson.annotations.Serializable",
        "import java.io.Serializable"
      ],
      "tags": [
        "imports",
        "annotations",
        "serialization",
        "codegen",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "imports"
    },
    {
      "id": "kt-cf-001",
      "name": "When Expression Exhaustiveness with Sealed Classes",
      "description": "Enforce all sealed class branches in when expression",
      "scenario": "Developer using a when expression to handle a sealed class hierarchy. When used as an expression (returning a value), when must be exhaustive. The compiler tracks which sealed class subtypes have been handled and requires all branches or an else clause.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "state",
            "type_expr": "UiState",
            "scope": "local"
          }
        ],
        "class_definitions": [
          {
            "name": "UiState",
            "bases": [
              "sealed class"
            ]
          },
          {
            "name": "Loading",
            "bases": [
              "UiState"
            ]
          },
          {
            "name": "Success",
            "bases": [
              "UiState"
            ],
            "instance_vars": [
              {
                "name": "data",
                "type_expr": "List<String>"
              }
            ]
          },
          {
            "name": "Error",
            "bases": [
              "UiState"
            ],
            "instance_vars": [
              {
                "name": "error",
                "type_expr": "Throwable"
              }
            ]
          }
        ],
        "expected_type": "Int",
        "control_flow": {
          "function_name": "getStatusCode",
          "expected_return_type": "Int"
        }
      },
      "expected_effect": "Masks tokens that create non-exhaustive when expressions. Tracks which sealed class subtypes have been handled in branches. Requires all three subtypes (Loading, Success, Error) to be covered, or an else branch.",
      "valid_outputs": [
        "when (state) {\n                is Loading -> 0\n                is Success -> 200\n                is Error -> 500\n            }",
        "when (state) {\n                is Loading -> 0\n                is Success -> 200\n                else -> 500\n            }"
      ],
      "invalid_outputs": [
        "when (state) {\n                is Loading -> 0\n                is Success -> 200\n            }",
        "when (state) {\n                is Success -> 200\n            }",
        "state.data.size"
      ],
      "tags": [
        "controlflow",
        "when",
        "sealed-class",
        "exhaustiveness",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "controlflow"
    },
    {
      "id": "kt-cf-002",
      "name": "Coroutine Scope and Context",
      "description": "Enforce proper coroutine scope for suspend calls",
      "scenario": "Developer working inside a coroutine scope (launch, async block) and calling suspend functions. Coroutine context tracking ensures suspend functions are only called from valid contexts (other suspend functions or coroutine builders). Using coroutineContext property requires being inside a suspend context.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "scope",
            "type_expr": "CoroutineScope",
            "scope": "local"
          },
          {
            "name": "userId",
            "type_expr": "String",
            "scope": "local"
          }
        ],
        "function_signatures": [
          {
            "name": "fetchData",
            "params": [
              {
                "name": "id",
                "type_expr": "String"
              }
            ],
            "return_type": "Data",
            "is_async": true
          }
        ],
        "expected_type": "Unit",
        "control_flow": {
          "function_name": "loadUser"
        }
      },
      "expected_effect": "Masks direct suspend function calls when outside suspend context. Requires coroutine builders (scope.launch { }, scope.async { }, runBlocking { }) to call suspend functions from regular contexts. Allows direct calls inside suspend functions.",
      "valid_outputs": [
        "scope.launch { fetchData(userId) }",
        "scope.async { fetchData(userId) }",
        "runBlocking { fetchData(userId) }"
      ],
      "invalid_outputs": [
        "fetchData(userId)",
        "val data = fetchData(userId)"
      ],
      "tags": [
        "controlflow",
        "coroutines",
        "suspend",
        "scope",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "controlflow"
    },
    {
      "id": "kt-cf-003",
      "name": "Null-Check Smart Cast Branches",
      "description": "Track smart casts after null checks with let/run/also",
      "scenario": "Developer using Kotlin's scope functions (let, run, also) with nullable types. After a null check (user != null, user?.let), the type is smart cast to non-null within the safe scope. The control flow domain must track which variables have been null-checked in which branches.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "user",
            "type_expr": "User?",
            "scope": "local"
          }
        ],
        "class_definitions": [
          {
            "name": "User",
            "instance_vars": [
              {
                "name": "name",
                "type_expr": "String"
              },
              {
                "name": "email",
                "type_expr": "String"
              }
            ]
          }
        ],
        "expected_type": "String",
        "control_flow": {
          "function_name": "getUserName",
          "expected_return_type": "String"
        }
      },
      "expected_effect": "Masks unsafe nullable access outside null-check scopes. After 'user?.let { }', inside the lambda 'it' is User (non-null). After 'if (user != null)', inside the true branch 'user' is smart cast to User. Blocks unsafe access outside these scopes.",
      "valid_outputs": [
        "user?.let { it.name } ?: \"Unknown\"",
        "user?.name ?: \"Unknown\"",
        "if (user != null) user.name else \"Unknown\"",
        "user?.run { name } ?: \"Unknown\""
      ],
      "invalid_outputs": [
        "user.name",
        "user.email",
        "if (user != null) \"name\" else user.name"
      ],
      "tags": [
        "controlflow",
        "smart-cast",
        "null-safety",
        "scope-functions",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "controlflow"
    },
    {
      "id": "kt-sem-001",
      "name": "Non-Null Contract with require/check",
      "description": "Enforce Kotlin contracts with require/check/checkNotNull",
      "scenario": "Developer using Kotlin's contract functions (require, check, checkNotNull) to enforce preconditions and invariants. These functions have compiler contracts that enable smart casts and null-safety guarantees. After 'requireNotNull(value)', the compiler knows value is non-null.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "input",
            "type_expr": "String?",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "processInput",
            "params": [
              {
                "name": "input",
                "type_expr": "String?"
              }
            ],
            "return_type": "String"
          }
        ],
        "expected_type": "String",
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "input != null",
            "scope": "processInput",
            "variables": [
              "input"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that don't enforce the non-null precondition. Allows requireNotNull(input), require(input != null), checkNotNull(input). After these calls, masks unsafe nullable operations since the compiler knows the value is non-null via contracts.",
      "valid_outputs": [
        "requireNotNull(input) { \"Input cannot be null\" }",
        "checkNotNull(input)",
        "require(input != null)",
        "return requireNotNull(input).uppercase()"
      ],
      "invalid_outputs": [
        "return input.uppercase()",
        "if (input != null) return input else throw Exception()"
      ],
      "tags": [
        "semantics",
        "contracts",
        "preconditions",
        "null-safety",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "semantics"
    },
    {
      "id": "kt-sem-002",
      "name": "Collection Bounds with indices/getOrNull",
      "description": "Enforce safe collection access with bounds checking",
      "scenario": "Developer accessing collection elements safely using Kotlin's safe collection operators. Unlike Java, Kotlin provides getOrNull, getOrElse, indices property, and elementAtOrNull to avoid IndexOutOfBoundsException. Code should prefer these safe APIs.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "items",
            "type_expr": "List<String>",
            "scope": "local"
          },
          {
            "name": "index",
            "type_expr": "Int",
            "scope": "local"
          }
        ],
        "expected_type": "String?",
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "index >= 0",
            "scope": "getItem",
            "variables": [
              "index"
            ]
          },
          {
            "kind": "invariant",
            "expression": "index in items.indices || result == null",
            "scope": "getItem",
            "variables": [
              "index",
              "items",
              "result"
            ]
          }
        ]
      },
      "expected_effect": "Masks unsafe collection access patterns. Prefers getOrNull(index) over get(index), 'index in items.indices' checks over manual comparisons, elementAtOrNull over elementAt. Blocks direct array-style access items[index] without bounds checking.",
      "valid_outputs": [
        "items.getOrNull(index)",
        "if (index in items.indices) items[index] else null",
        "items.elementAtOrNull(index)",
        "items.getOrElse(index) { null }"
      ],
      "invalid_outputs": [
        "items[index]",
        "items.get(index)",
        "if (index >= 0 && index < items.size) items[index] else null"
      ],
      "tags": [
        "semantics",
        "collections",
        "bounds-checking",
        "safety",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "semantics"
    },
    {
      "id": "kt-sem-003",
      "name": "Coroutine Cancellation Check",
      "description": "Enforce cooperative cancellation with isActive/ensureActive",
      "scenario": "Developer writing a long-running suspend function that should respect coroutine cancellation. Kotlin coroutines are cooperatively cancelled, meaning the code must explicitly check for cancellation using isActive, ensureActive(), or yield(). Tight loops without cancellation checks can block cancellation.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "items",
            "type_expr": "List<Item>",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "processItems",
            "params": [
              {
                "name": "items",
                "type_expr": "List<Item>"
              }
            ],
            "return_type": "List<Result>",
            "is_async": true
          }
        ],
        "expected_type": "List<Result>",
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "coroutineContext[Job]?.isActive == true",
            "scope": "processItems",
            "variables": [
              "coroutineContext"
            ]
          }
        ]
      },
      "expected_effect": "Masks tight loops without cancellation checks in suspend functions. Requires periodic calls to ensureActive(), isActive checks, or yield() within loops. Blocks simple for/while loops over large collections without cancellation support.",
      "valid_outputs": [
        "items.map { item ->\n                ensureActive()\n                processItem(item)\n            }",
        "for (item in items) {\n                if (!isActive) break\n                processItem(item)\n            }",
        "items.map { item ->\n                yield()\n                processItem(item)\n            }"
      ],
      "invalid_outputs": [
        "items.map { processItem(it) }",
        "for (item in items) { processItem(item) }"
      ],
      "tags": [
        "semantics",
        "coroutines",
        "cancellation",
        "cooperative",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "semantics"
    },
    {
      "id": "kt-syn-001",
      "name": "Kotlinx.serialization Schema",
      "description": "Enforce valid @Serializable data class structure",
      "scenario": "Developer defining a data class with @Serializable annotation for kotlinx.serialization. The annotation requires specific constraints: all properties must be serializable types, custom serializers must be specified with @Serializable(with=...), and @SerialName must be a compile-time constant string.",
      "spec": {
        "version": "1.0",
        "structural_tag": "serializable_data_class",
        "language": "kotlin",
        "class_definitions": [
          {
            "name": "User",
            "instance_vars": [
              {
                "name": "id",
                "type_expr": "String"
              },
              {
                "name": "username",
                "type_expr": "String"
              },
              {
                "name": "email",
                "type_expr": "String"
              }
            ]
          }
        ],
        "imports": [
          {
            "module": "kotlinx.serialization",
            "name": "Serializable"
          },
          {
            "module": "kotlinx.serialization",
            "name": "SerialName"
          }
        ]
      },
      "expected_effect": "Masks tokens that create invalid serializable structures. Requires data class (not regular class), val properties (not var unless mutable), primitive or other @Serializable types for properties. Enforces @SerialName syntax with string literals.",
      "valid_outputs": [
        "@Serializable\ndata class User(\n    val id: String,\n    @SerialName(\"user_name\")\n    val username: String,\n    val email: String\n)",
        "@Serializable\ndata class Response(\n    val status: Int,\n    val data: List<User>\n)"
      ],
      "invalid_outputs": [
        "@Serializable\nclass User(val id: String)",
        "@Serializable\ndata class User(var id: String)",
        "@Serializable\ndata class User(\n    @SerialName(getName())\n    val id: String\n)"
      ],
      "tags": [
        "syntax",
        "serialization",
        "annotations",
        "data-class",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "syntax"
    },
    {
      "id": "kt-syn-002",
      "name": "Kotlin DSL Builder Pattern",
      "description": "Enforce type-safe builder DSL syntax",
      "scenario": "Developer using Kotlin's type-safe builder DSL pattern, commonly seen in frameworks like kotlinx.html, Ktor routing, Jetpack Compose. Builder DSLs use lambda with receiver, require @DslMarker to prevent scope leaks, and specific function syntax for the builder methods.",
      "spec": {
        "version": "1.0",
        "structural_tag": "dsl_builder",
        "language": "kotlin",
        "expected_type": "Html"
      },
      "expected_effect": "Masks tokens that don't follow DSL builder patterns. Requires lambda with receiver syntax ClassName.() -> Unit, enforces proper nesting without explicit receivers (implicit 'this'), blocks return statements inside builder lambdas.",
      "valid_outputs": [
        "html {\n    head {\n        title { +\"My Page\" }\n    }\n    body {\n        h1 { +\"Welcome\" }\n        p { +\"Content here\" }\n    }\n}",
        "routing {\n    get(\"/users\") {\n        call.respond(users)\n    }\n    post(\"/users\") {\n        val user = call.receive<User>()\n        call.respond(user)\n    }\n}"
      ],
      "invalid_outputs": [
        "html {\n    this.head {\n        this.title { +\"Title\" }\n    }\n}",
        "html {\n    head {\n        return title { +\"Title\" }\n    }\n}"
      ],
      "tags": [
        "syntax",
        "dsl",
        "builder",
        "lambda-with-receiver",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "syntax"
    },
    {
      "id": "kt-syn-003",
      "name": "Spring/Ktor Annotation Syntax",
      "description": "Enforce framework annotation patterns",
      "scenario": "Developer writing Spring Boot REST controller or Ktor routing with proper annotation syntax. Spring requires @RestController, @RequestMapping, @GetMapping etc. Ktor uses routing DSL. Each has specific syntax requirements for path parameters, request bodies, and response types.",
      "spec": {
        "version": "1.0",
        "structural_tag": "rest_controller",
        "language": "kotlin",
        "imports": [
          {
            "module": "org.springframework.web.bind.annotation",
            "name": "RestController"
          },
          {
            "module": "org.springframework.web.bind.annotation",
            "name": "GetMapping"
          },
          {
            "module": "org.springframework.web.bind.annotation",
            "name": "PathVariable"
          }
        ]
      },
      "expected_effect": "Masks tokens that don't follow framework annotation patterns. For Spring, requires proper annotation syntax with path templates in strings, @PathVariable parameters matching template names. For Ktor, requires routing DSL with proper call.receive/call.respond patterns.",
      "valid_outputs": [
        "@RestController\n@RequestMapping(\"/api/users\")\nclass UserController {\n    @GetMapping(\"/{id}\")\n    fun getUser(@PathVariable id: String): User {\n        return userService.findById(id)\n    }\n}",
        "routing {\n    route(\"/api/users\") {\n        get(\"/{id}\") {\n            val id = call.parameters[\"id\"]!!\n            call.respond(userService.findById(id))\n        }\n    }\n}"
      ],
      "invalid_outputs": [
        "@RestController\nclass UserController {\n    @GetMapping(\"/{id}\")\n    fun getUser(@PathVariable userId: String): User\n}",
        "@GetMapping(\"/users/{id}\")\nfun getUser(id: String): User"
      ],
      "tags": [
        "syntax",
        "annotations",
        "spring",
        "ktor",
        "rest",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "syntax"
    },
    {
      "id": "kt-coro-001",
      "name": "Flow Operators and Cold Streams",
      "description": "Enforce Flow operator chains with cold stream semantics",
      "scenario": "Developer building a Flow pipeline using operators like map, filter, collect. Flow is a cold stream - it doesn't emit values until collected. Common mistakes include not calling collect(), mixing Flow with sequences, or trying to get values synchronously. The constraint enforces proper Flow usage including terminal operators and suspend context.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "numbers",
            "type_expr": "Flow<Int>",
            "scope": "local"
          }
        ],
        "function_signatures": [
          {
            "name": "processNumbers",
            "params": [
              {
                "name": "numbers",
                "type_expr": "Flow<Int>"
              }
            ],
            "return_type": "Unit",
            "is_async": true
          }
        ],
        "expected_type": "Unit",
        "imports": [
          {
            "module": "kotlinx.coroutines.flow",
            "name": "Flow"
          },
          {
            "module": "kotlinx.coroutines.flow",
            "name": "map"
          },
          {
            "module": "kotlinx.coroutines.flow",
            "name": "filter"
          },
          {
            "module": "kotlinx.coroutines.flow",
            "name": "collect"
          }
        ],
        "control_flow": {
          "function_name": "processNumbers",
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "flow_must_be_collected",
            "scope": "processNumbers",
            "variables": [
              "numbers"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that create incomplete Flow chains without terminal operators. Blocks 'numbers.map { it * 2 }' without collect(). Requires terminal operators: collect(), toList(), toSet(), first(), single(). Enforces suspend context for Flow collection.",
      "valid_outputs": [
        "numbers\n    .map { it * 2 }\n    .filter { it > 10 }\n    .collect { println(it) }",
        "numbers\n    .map { it.toString() }\n    .toList()",
        "numbers\n    .filter { it % 2 == 0 }\n    .first()",
        "val sum = numbers\n    .map { it * 2 }\n    .fold(0) { acc, value -> acc + value }"
      ],
      "invalid_outputs": [
        "numbers.map { it * 2 }",
        "val flow = numbers.filter { it > 0 }",
        "numbers.collect { println(it) }; numbers.collect { }"
      ],
      "tags": [
        "coroutines",
        "flow",
        "cold-stream",
        "operators",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "coroutines"
    },
    {
      "id": "kt-coro-002",
      "name": "Suspend Function Composition",
      "description": "Enforce proper suspend function composition with coroutineScope",
      "scenario": "Developer composing multiple suspend function calls, possibly in parallel. Kotlin provides coroutineScope { } for structured concurrency and parallel execution with async/await. Common patterns: sequential awaits, parallel async then awaitAll, or mixed. Constraints ensure proper scoping and exception handling.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "userId",
            "type_expr": "String",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "fetchUser",
            "params": [
              {
                "name": "id",
                "type_expr": "String"
              }
            ],
            "return_type": "User",
            "is_async": true
          },
          {
            "name": "fetchPosts",
            "params": [
              {
                "name": "userId",
                "type_expr": "String"
              }
            ],
            "return_type": "List<Post>",
            "is_async": true
          },
          {
            "name": "fetchComments",
            "params": [
              {
                "name": "userId",
                "type_expr": "String"
              }
            ],
            "return_type": "List<Comment>",
            "is_async": true
          },
          {
            "name": "loadUserData",
            "params": [
              {
                "name": "userId",
                "type_expr": "String"
              }
            ],
            "return_type": "Result",
            "is_async": true
          }
        ],
        "expected_type": "Result",
        "imports": [
          {
            "module": "kotlinx.coroutines",
            "name": "coroutineScope"
          },
          {
            "module": "kotlinx.coroutines",
            "name": "async"
          },
          {
            "module": "kotlinx.coroutines",
            "name": "awaitAll"
          }
        ],
        "control_flow": {
          "function_name": "loadUserData",
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "all_async_calls_awaited",
            "scope": "loadUserData"
          }
        ]
      },
      "expected_effect": "Masks tokens that launch async operations without proper scoping. Requires coroutineScope { } for parallel operations. Blocks raw async { } without await, enforces structured concurrency. Prevents forgotten await() calls on Deferred values.",
      "valid_outputs": [
        "val user = fetchUser(userId)\nval posts = fetchPosts(userId)\nval comments = fetchComments(userId)\nResult(user, posts, comments)",
        "coroutineScope {\n    val userDeferred = async { fetchUser(userId) }\n    val postsDeferred = async { fetchPosts(userId) }\n    val user = userDeferred.await()\n    val posts = postsDeferred.await()\n    Result(user, posts, emptyList())\n}",
        "coroutineScope {\n    val (user, posts) = listOf(\n        async { fetchUser(userId) },\n        async { fetchPosts(userId) }\n    ).awaitAll()\n    Result(user, posts, emptyList())\n}"
      ],
      "invalid_outputs": [
        "val deferred = async { fetchUser(userId) }\nfetchPosts(userId)",
        "async { fetchUser(userId) }\nasync { fetchPosts(userId) }",
        "GlobalScope.async { fetchUser(userId) }"
      ],
      "tags": [
        "coroutines",
        "suspend",
        "composition",
        "async-await",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "coroutines"
    },
    {
      "id": "kt-coro-003",
      "name": "CoroutineScope Management and Lifecycle",
      "description": "Enforce proper CoroutineScope lifecycle and cancellation",
      "scenario": "Developer managing a CoroutineScope tied to a lifecycle (Android ViewModel, Service class). Proper scope management means: creating scope with SupervisorJob for independent child failures, using lifecycleScope or viewModelScope when available, always canceling scopes in cleanup, avoiding GlobalScope. Constraints enforce these best practices.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "expected_type": "CoroutineScope",
        "imports": [
          {
            "module": "kotlinx.coroutines",
            "name": "CoroutineScope"
          },
          {
            "module": "kotlinx.coroutines",
            "name": "SupervisorJob"
          },
          {
            "module": "kotlinx.coroutines",
            "name": "Dispatchers"
          },
          {
            "module": "kotlinx.coroutines",
            "name": "cancel"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "scope_has_job",
            "scope": "createScope"
          },
          {
            "kind": "postcondition",
            "expression": "scope_is_cancellable",
            "scope": "createScope"
          }
        ]
      },
      "expected_effect": "Masks tokens that create scopes without proper Job management. Requires SupervisorJob() or Job() in scope creation. Blocks GlobalScope usage. In cleanup methods, requires scope.cancel() calls. Enforces Dispatcher selection (Main, IO, Default).",
      "valid_outputs": [
        "CoroutineScope(SupervisorJob() + Dispatchers.Main)",
        "CoroutineScope(Job() + Dispatchers.IO)",
        "viewModelScope.launch { }",
        "lifecycleScope.launch { }",
        "private val scope = CoroutineScope(SupervisorJob())\n\nfun onCleanup() {\n    scope.cancel()\n}"
      ],
      "invalid_outputs": [
        "GlobalScope.launch { }",
        "CoroutineScope(Dispatchers.Main)",
        "val scope = CoroutineScope(SupervisorJob())\n// ... no cancel() call in cleanup"
      ],
      "tags": [
        "coroutines",
        "scope",
        "lifecycle",
        "cancellation",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "coroutines"
    },
    {
      "id": "kt-coro-004",
      "name": "Flow Exception Handling with catch",
      "description": "Enforce proper exception handling in Flow pipelines",
      "scenario": "Developer building a Flow pipeline that can throw exceptions during collection or transformation. Flow provides catch { } operator for exception handling. Unlike try-catch, catch { } only handles upstream exceptions. Constraints enforce proper exception handling patterns and prevent swallowed exceptions.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "source",
            "type_expr": "Flow<Data>",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "processData",
            "params": [
              {
                "name": "data",
                "type_expr": "Data"
              }
            ],
            "return_type": "Result"
          }
        ],
        "expected_type": "Flow<Result>",
        "imports": [
          {
            "module": "kotlinx.coroutines.flow",
            "name": "Flow"
          },
          {
            "module": "kotlinx.coroutines.flow",
            "name": "catch"
          },
          {
            "module": "kotlinx.coroutines.flow",
            "name": "map"
          }
        ]
      },
      "expected_effect": "Masks unsafe Flow exception handling. Requires catch { } operator for flows that can throw. Blocks try-catch around collect() without rethrowing. Enforces that catch { } emits fallback values or rethrows to prevent silent failures.",
      "valid_outputs": [
        "source\n    .map { processData(it) }\n    .catch { e ->\n        emit(Result.Error(e.message))\n    }",
        "source\n    .map { processData(it) }\n    .catch { e ->\n        logger.error(\"Processing failed\", e)\n        throw e\n    }",
        "source\n    .map { processData(it) }\n    .catch { e ->\n        when (e) {\n            is IOException -> emit(Result.NetworkError)\n            else -> throw e\n        }\n    }"
      ],
      "invalid_outputs": [
        "source\n    .map { processData(it) }\n    .catch { }",
        "try {\n    source.collect { processData(it) }\n} catch (e: Exception) { }"
      ],
      "tags": [
        "coroutines",
        "flow",
        "exceptions",
        "error-handling",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "coroutines"
    },
    {
      "id": "kt-coro-005",
      "name": "StateFlow and SharedFlow Hot Streams",
      "description": "Enforce proper hot stream creation and subscription",
      "scenario": "Developer using StateFlow or SharedFlow for hot streams (e.g., UI state, events). Unlike Flow, these are hot - they emit even without collectors. StateFlow requires initial value, SharedFlow needs replay/buffer config. Common mistakes: not setting replay, forgetting initial value, not using stateIn/shareIn for cold-to-hot conversion.",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "scope",
            "type_expr": "CoroutineScope",
            "scope": "local"
          }
        ],
        "expected_type": "StateFlow<UiState>",
        "imports": [
          {
            "module": "kotlinx.coroutines.flow",
            "name": "MutableStateFlow"
          },
          {
            "module": "kotlinx.coroutines.flow",
            "name": "StateFlow"
          },
          {
            "module": "kotlinx.coroutines.flow",
            "name": "stateIn"
          }
        ]
      },
      "expected_effect": "Masks tokens that create StateFlow without initial value or SharedFlow without configuration. Requires MutableStateFlow(initialValue). For cold-to-hot conversion, requires stateIn with SharingStarted policy. Blocks missing scope or improper sharing configuration.",
      "valid_outputs": [
        "MutableStateFlow<UiState>(UiState.Loading)",
        "MutableStateFlow(UiState.Idle)",
        "coldFlow\n    .stateIn(\n        scope = scope,\n        started = SharingStarted.WhileSubscribed(5000),\n        initialValue = UiState.Loading\n    )",
        "MutableSharedFlow<Event>(\n    replay = 1,\n    extraBufferCapacity = 64\n)"
      ],
      "invalid_outputs": [
        "MutableStateFlow<UiState>()",
        "coldFlow.stateIn(scope)",
        "MutableSharedFlow<Event>()"
      ],
      "tags": [
        "coroutines",
        "stateflow",
        "sharedflow",
        "hot-streams",
        "kotlin"
      ],
      "language": "kotlin",
      "domain": "coroutines"
    },
    {
      "id": "swift-types-001",
      "name": "Optional Chaining",
      "description": "Safe unwrapping with optional chaining for nested optionals",
      "scenario": "Developer accessing nested properties through optional values. Must use optional chaining (?.) instead of force unwrapping (!) to safely handle nil values at any level of the chain.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"user\" \"?.\" property-chain\n        property-chain ::= \"profile\" \"?.\" \"bio\"\n                         | \"profile\" \"?.\" \"avatar\" \"?.\" \"absoluteString\"\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "user",
            "type_expr": "User?",
            "scope": "local",
            "mutable": false
          }
        ],
        "expected_type": "String?",
        "type_aliases": {
          "User": "struct { profile: Profile?, name: String }",
          "Profile": "struct { bio: String?, avatar: URL? }"
        }
      },
      "expected_effect": "Masks tokens that would force unwrap (!) or access properties without optional chaining. Ensures safe navigation through optional hierarchy.",
      "valid_outputs": [
        "user?.profile?.bio",
        "user?.profile?.avatar?.absoluteString",
        "user?.name"
      ],
      "invalid_outputs": [
        "user!.profile!.bio",
        "user.profile.bio",
        "(user?.profile)!.bio"
      ],
      "tags": [
        "types",
        "optionals",
        "chaining",
        "safety"
      ],
      "language": "swift",
      "domain": "types"
    },
    {
      "id": "swift-types-002",
      "name": "Protocol with Associated Types",
      "description": "Generic protocol conformance using associatedtype",
      "scenario": "Developer implementing a Container protocol that requires an associated type Item. The implementation must specify the concrete type for Item and provide methods that work with that type parameter.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"typealias Item = Element\" ws newline method-impl\n        method-impl ::= \"var count: Int { items.count }\"\n                      | \"subscript(i: Int) -> Element { items[i] }\"\n        ws ::= \" \"*\n        newline ::= \"\\n\" ws\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "Stack<Element>",
            "scope": "local"
          },
          {
            "name": "items",
            "type_expr": "[Element]",
            "scope": "local"
          }
        ],
        "type_aliases": {
          "Container": "protocol { associatedtype Item; func count() -> Int; subscript(i: Int) -> Item }"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "Item == Element",
            "scope": "Stack",
            "variables": [
              "Item",
              "Element"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would use incompatible types for the associated type. Ensures Item matches Element and all protocol requirements are satisfied.",
      "valid_outputs": [
        "typealias Item = Element\nvar count: Int { items.count }",
        "typealias Item = Element\nsubscript(i: Int) -> Element { items[i] }",
        "typealias Item = Element\nfunc append(_ item: Element) { items.append(item) }"
      ],
      "invalid_outputs": [
        "typealias Item = String",
        "typealias Item = Any",
        "var count: String { '\\(items.count)' }"
      ],
      "tags": [
        "types",
        "protocols",
        "generics",
        "associated-types"
      ],
      "language": "swift",
      "domain": "types"
    },
    {
      "id": "swift-types-003",
      "name": "Actor Isolation and MainActor",
      "description": "Constraint generation for actor-isolated state and MainActor",
      "scenario": "Developer working with actor-isolated state that must be accessed on the MainActor. Properties marked @MainActor can only be accessed from the main thread, requiring await in async contexts or direct access in @MainActor functions.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"@MainActor\" ws \"func updateTitle(_ newTitle: String)\" ws \"{\" ws body ws \"}\"\n        body ::= \"self.title = newTitle\"\n               | \"title = newTitle\"\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "@MainActor ViewModel",
            "scope": "local"
          },
          {
            "name": "title",
            "type_expr": "String",
            "scope": "local"
          }
        ],
        "control_flow": {
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "@MainActor.run or await MainActor",
            "scope": "updateTitle",
            "variables": [
              "title"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would access MainActor-isolated state without proper isolation. Enforces @MainActor annotation on functions that update UI-bound state.",
      "valid_outputs": [
        "@MainActor func updateTitle(_ newTitle: String) { self.title = newTitle }",
        "@MainActor func updateTitle(_ newTitle: String) { title = newTitle }",
        "nonisolated func scheduleUpdate() { Task { await updateTitle('New') } }"
      ],
      "invalid_outputs": [
        "func updateTitle(_ newTitle: String) { self.title = newTitle }",
        "nonisolated func updateTitle(_ newTitle: String) { title = newTitle }",
        "func updateTitle(_ newTitle: String) async { title = newTitle }"
      ],
      "tags": [
        "types",
        "actors",
        "concurrency",
        "main-actor",
        "isolation"
      ],
      "language": "swift",
      "domain": "types"
    },
    {
      "id": "swift-imports-001",
      "name": "Framework Availability Check",
      "description": "Use #available to check for iOS/macOS version-specific APIs",
      "scenario": "Developer using SwiftUI features that are only available in iOS 15+. Must guard usage with #available check to prevent runtime crashes on older OS versions. The constraint ensures proper availability checks.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"if #available(iOS \" version \", *) {\" ws body ws \"}\"\n        version ::= \"15\" | \"16\" | \"17\"\n        body ::= \".task {\" async-code \"}\"\n               | \".refreshable {\" async-code \"}\"\n               | \".searchable(text: $searchText)\"\n        async-code ::= \"await \" identifier \"()\"\n        identifier ::= [a-z][a-zA-Z0-9]*\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "imports": [
          {
            "module": "SwiftUI"
          }
        ],
        "available_modules": [
          "Combine",
          "Foundation",
          "SwiftUI"
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "if #available(iOS 15, *)",
            "scope": "body"
          }
        ]
      },
      "expected_effect": "Masks tokens that would use iOS 15+ APIs without availability checks. Ensures version-gated features are properly guarded.",
      "valid_outputs": [
        "if #available(iOS 15, *) { .task { await loadData() } }",
        "if #available(iOS 15, *) { .refreshable { await refresh() } }",
        "if #available(iOS 15, macOS 12, *) { .searchable(text: $searchText) }"
      ],
      "invalid_outputs": [
        ".task { await loadData() }",
        ".refreshable { await refresh() }",
        "if #available(iOS 14, *) { .task { } }"
      ],
      "tags": [
        "imports",
        "availability",
        "version",
        "swiftui"
      ],
      "language": "swift",
      "domain": "imports"
    },
    {
      "id": "swift-imports-002",
      "name": "Platform Conditional Compilation",
      "description": "Use #if os() to conditionally compile platform-specific code",
      "scenario": "Developer writing cross-platform Swift code that needs different imports for macOS vs iOS. Using #if os(macOS) and #if os(iOS) to conditionally import AppKit vs UIKit while maintaining type safety.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= platform-import+\n        platform-import ::= \"#if os(macOS)\" ws \"import AppKit\" ws \"#endif\"\n                          | \"#if os(iOS)\" ws \"import UIKit\" ws \"#endif\"\n                          | \"#if canImport(\" module \")\" ws \"import \" module ws \"#endif\"\n        module ::= \"AppKit\" | \"UIKit\" | \"Combine\"\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "imports": [
          {
            "module": "Foundation"
          }
        ],
        "available_modules": [
          "AppKit",
          "Foundation",
          "UIKit"
        ]
      },
      "expected_effect": "Masks tokens that would import platform-specific frameworks without guards. Ensures AppKit is only imported on macOS, UIKit only on iOS.",
      "valid_outputs": [
        "#if os(macOS)\nimport AppKit\n#endif",
        "#if os(iOS)\nimport UIKit\n#endif",
        "#if canImport(AppKit)\nimport AppKit\n#endif",
        "#if os(macOS)\nimport AppKit\n#elseif os(iOS)\nimport UIKit\n#endif"
      ],
      "invalid_outputs": [
        "import AppKit",
        "import UIKit",
        "#if os(macOS)\nimport UIKit\n#endif"
      ],
      "tags": [
        "imports",
        "platform",
        "conditional",
        "cross-platform"
      ],
      "language": "swift",
      "domain": "imports"
    },
    {
      "id": "swift-imports-003",
      "name": "Module Visibility with @_exported",
      "description": "Re-export module symbols using @_exported import",
      "scenario": "Developer creating a framework wrapper that re-exports underlying modules. Using @_exported import to make symbols from dependencies available to framework clients without requiring separate imports.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= export-import+\n        export-import ::= \"@_exported import \" module\n                        | \"import \" module\n        module ::= \"Foundation\" | \"Combine\" | \"SwiftUI\"\n        ",
        "language": "swift",
        "imports": [
          {
            "module": "Foundation"
          }
        ],
        "available_modules": [
          "Combine",
          "Foundation",
          "SwiftUI"
        ],
        "forbidden_imports": [
          "UIKit"
        ]
      },
      "expected_effect": "Masks tokens that would import forbidden modules or fail to re-export when needed. Ensures @_exported is used for framework public API surface.",
      "valid_outputs": [
        "@_exported import Foundation",
        "@_exported import Combine",
        "@_exported import SwiftUI",
        "import Foundation\n@_exported import Combine"
      ],
      "invalid_outputs": [
        "import UIKit",
        "@_exported import UIKit",
        "public import Foundation"
      ],
      "tags": [
        "imports",
        "visibility",
        "framework",
        "re-export"
      ],
      "language": "swift",
      "domain": "imports"
    },
    {
      "id": "swift-controlflow-001",
      "name": "Guard Let Early Exit",
      "description": "Use guard let to unwrap optionals with early return",
      "scenario": "Developer unwrapping multiple optional values in a function. Must use guard let statements that exit early if any value is nil, making the unwrapped values available in the happy path scope.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= guard-chain body\n        guard-chain ::= \"guard let \" identifier \" = \" identifier (\",\" ws \"let \" identifier \" = \" identifier)* \" else { return nil }\"\n        body ::= ws \"return User(id: \" identifier \", token: \" identifier \")\"\n        identifier ::= [a-z][a-zA-Z0-9]*\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "userId",
            "type_expr": "String?",
            "scope": "parameter"
          },
          {
            "name": "token",
            "type_expr": "String?",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "authenticate",
          "function_signature": {
            "name": "authenticate",
            "params": [
              {
                "name": "userId",
                "type_expr": "String?"
              },
              {
                "name": "token",
                "type_expr": "String?"
              }
            ],
            "return_type": "User?"
          },
          "expected_return_type": "User?"
        },
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "userId != nil && token != nil",
            "scope": "authenticate_body",
            "variables": [
              "userId",
              "token"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would access optionals without unwrapping or fail to provide early exit. Ensures guard let pattern with proper scope handling.",
      "valid_outputs": [
        "guard let userId = userId, let token = token else { return nil }\nreturn User(id: userId, token: token)",
        "guard let id = userId else { return nil }\nguard let tok = token else { return nil }\nreturn User(id: id, token: tok)",
        "guard let userId = userId, let token = token else { return nil }\nreturn authenticateUser(userId, token)"
      ],
      "invalid_outputs": [
        "if let userId = userId { return User(id: userId, token: token!) }",
        "return User(id: userId!, token: token!)",
        "guard userId != nil else { return nil }\nreturn User(id: userId, token: token)"
      ],
      "tags": [
        "controlflow",
        "guard",
        "optionals",
        "early-exit"
      ],
      "language": "swift",
      "domain": "controlflow"
    },
    {
      "id": "swift-controlflow-002",
      "name": "Actor Async Context and MainActor",
      "description": "Constrain async/await calls within actor isolation boundaries",
      "scenario": "Developer writing async code that interacts with MainActor-isolated state. Must use await when calling MainActor methods from async context, and can elide await when already on MainActor.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= async-call ws main-actor-call\n        async-call ::= \"let data = await fetchData()\"\n        main-actor-call ::= \"await viewModel.update(data)\"\n                          | \"await MainActor.run { viewModel.update(data) }\"\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "DataManager",
            "scope": "local"
          },
          {
            "name": "viewModel",
            "type_expr": "@MainActor ViewModel",
            "scope": "local"
          }
        ],
        "control_flow": {
          "function_name": "loadData",
          "function_signature": {
            "name": "loadData",
            "params": [],
            "return_type": "Void",
            "is_async": true
          },
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "await for @MainActor access from non-MainActor context",
            "scope": "loadData",
            "variables": [
              "viewModel"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would access MainActor-isolated state without await. Enforces proper async/await usage across actor boundaries.",
      "valid_outputs": [
        "let data = await fetchData()\nawait viewModel.update(data)",
        "let data = await fetchData()\nawait MainActor.run { viewModel.update(data) }",
        "async { let data = await fetchData(); await viewModel.update(data) }"
      ],
      "invalid_outputs": [
        "let data = await fetchData()\nviewModel.update(data)",
        "let data = fetchData()\nawait viewModel.update(data)",
        "viewModel.update(await fetchData())"
      ],
      "tags": [
        "controlflow",
        "async",
        "await",
        "actors",
        "main-actor"
      ],
      "language": "swift",
      "domain": "controlflow"
    },
    {
      "id": "swift-controlflow-003",
      "name": "Result Builder Blocks",
      "description": "Constrain code within @resultBuilder blocks like @ViewBuilder",
      "scenario": "Developer building SwiftUI views using @ViewBuilder result builder. Within the builder block, only view-returning expressions are allowed, and control flow must use special builder constructs.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= view-expression+\n        view-expression ::= \"Text(\" string \")\"\n                          | \"Image(systemName: \" string \")\"\n                          | \"if \" condition \" {\" view-expression+ \"}\"\n                          | view-modifier\n        view-modifier ::= \".\" modifier-name \"(\" params \")\"\n        modifier-name ::= \"padding\" | \"foregroundColor\" | \"font\"\n        condition ::= identifier\n        identifier ::= [a-z][a-zA-Z0-9]*\n        string ::= '\"' [^\"]* '\"'\n        params ::= [^)]*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "ContentView",
            "scope": "local"
          },
          {
            "name": "isLoading",
            "type_expr": "Bool",
            "scope": "local"
          }
        ],
        "type_aliases": {
          "View": "protocol { var body: some View }"
        },
        "control_flow": {
          "function_name": "body",
          "function_signature": {
            "name": "body",
            "params": [],
            "return_type": "some View",
            "decorators": [
              "@ViewBuilder"
            ]
          },
          "expected_return_type": "some View"
        }
      },
      "expected_effect": "Masks tokens that would use standard Swift control flow (guard, for) instead of result builder equivalents. Ensures all expressions return View types.",
      "valid_outputs": [
        "if isLoading { ProgressView() } else { Text('Loaded') }",
        "Text('Title').font(.headline).padding()",
        "VStack { Text('Hello'); Image(systemName: 'star') }"
      ],
      "invalid_outputs": [
        "guard isLoading else { return Text('Error') }",
        "for item in items { Text(item) }",
        "let title = 'Hello'; Text(title)",
        "print('debug'); Text('Hello')"
      ],
      "tags": [
        "controlflow",
        "result-builder",
        "swiftui",
        "dsl"
      ],
      "language": "swift",
      "domain": "controlflow"
    },
    {
      "id": "swift-semantics-001",
      "name": "Force Unwrap Justification",
      "description": "Force unwrap only after precondition checks that guarantee non-nil",
      "scenario": "Developer force unwrapping an optional, which is normally discouraged. Force unwrap (!) is acceptable only when a precondition or prior check guarantees the value is non-nil. The constraint ensures this invariant.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= check ws force-unwrap\n        check ::= \"precondition(\" identifier \" != nil\" (\",\" ws string)? \")\"\n                | \"assert(\" identifier \" != nil\" (\",\" ws string)? \")\"\n                | \"guard \" identifier \" != nil else { fatalError() }\"\n        force-unwrap ::= \"return \" identifier \"!\"\n        identifier ::= [a-z][a-zA-Z0-9]*\n        string ::= '\"' [^\"]* '\"'\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "value",
            "type_expr": "Int?",
            "scope": "local"
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "value != nil",
            "scope": "force_unwrap_context",
            "variables": [
              "value"
            ]
          }
        ]
      },
      "expected_effect": "Masks force unwrap tokens unless preceded by precondition/assert. Ensures force unwraps are justified with explicit nil checks.",
      "valid_outputs": [
        "precondition(value != nil)\nreturn value!",
        "assert(value != nil, 'Value must be set')\nreturn value!",
        "guard value != nil else { fatalError() }\nreturn value!"
      ],
      "invalid_outputs": [
        "return value!",
        "if value != nil { return value! }",
        "assert(value != 0)\nreturn value!"
      ],
      "tags": [
        "semantics",
        "safety",
        "force-unwrap",
        "preconditions"
      ],
      "language": "swift",
      "domain": "semantics"
    },
    {
      "id": "swift-semantics-002",
      "name": "Actor State Consistency",
      "description": "Maintain actor state consistency across async suspension points",
      "scenario": "Developer modifying actor state across await suspension points. Must ensure state is consistent before and after suspension, avoiding data races or invalid intermediate states.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= state-transition ws async-call ws state-update ws state-restore\n        state-transition ::= \"isLoading = true\"\n        async-call ::= \"let result = await fetch()\"\n        state-update ::= \"data = result\"\n        state-restore ::= \"isLoading = false\"\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "actor DataStore",
            "scope": "local"
          },
          {
            "name": "data",
            "type_expr": "[String: Any]",
            "scope": "local"
          },
          {
            "name": "isLoading",
            "type_expr": "Bool",
            "scope": "local"
          }
        ],
        "control_flow": {
          "function_name": "updateData",
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "!(isLoading && data.isEmpty == false)",
            "scope": "updateData",
            "variables": [
              "isLoading",
              "data"
            ]
          },
          {
            "kind": "postcondition",
            "expression": "isLoading == false",
            "scope": "updateData",
            "variables": [
              "isLoading"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would leave actor state inconsistent across suspension. Ensures isLoading flag is properly managed and data updates are atomic.",
      "valid_outputs": [
        "isLoading = true\nlet result = await fetch()\ndata = result\nisLoading = false",
        "isLoading = true\ndefer { isLoading = false }\nlet result = await fetch()\ndata = result",
        "isLoading = true\ndo { data = await fetch(); isLoading = false } catch { isLoading = false; throw }"
      ],
      "invalid_outputs": [
        "let result = await fetch()\ndata = result",
        "isLoading = true\ndata = await fetch()",
        "data = await fetch()\nisLoading = false"
      ],
      "tags": [
        "semantics",
        "actors",
        "consistency",
        "async",
        "state"
      ],
      "language": "swift",
      "domain": "semantics"
    },
    {
      "id": "swift-semantics-003",
      "name": "Sendable Conformance Requirements",
      "description": "Ensure types crossing actor boundaries conform to Sendable",
      "scenario": "Developer passing data between actors or to global async functions. Swift 6 strict concurrency requires types to be Sendable when crossing isolation boundaries. The constraint ensures only Sendable-conforming types are used in cross-actor communication.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"await actor.send(\" sendable-value \")\"\n        sendable-value ::= \"Message(\" params \")\"\n                         | \"[\" sendable-element+ \"]\"\n                         | primitive-value\n        sendable-element ::= \"Message(\" params \")\" (\",\" ws)?\n        primitive-value ::= string | number | \"true\" | \"false\"\n        params ::= identifier \": \" value (\",\" ws identifier \": \" value)*\n        identifier ::= [a-z][a-zA-Z0-9]*\n        value ::= string | number | identifier\n        string ::= '\"' [^\"]* '\"'\n        number ::= [0-9]+\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "message",
            "type_expr": "Message",
            "scope": "parameter"
          }
        ],
        "type_aliases": {
          "Message": "struct Message: Sendable { let id: String; let content: String }",
          "UnsafeMessage": "class UnsafeMessage { var content: String }"
        },
        "control_flow": {
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "Message: Sendable",
            "scope": "sendMessage",
            "variables": [
              "Message"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would pass non-Sendable types across actor boundaries. Ensures only value types, immutable references, or Sendable-conforming types are used in async actor calls.",
      "valid_outputs": [
        "await actor.send(Message(id: '1', content: 'Hello'))",
        "await actor.send([Message(id: '1', content: 'A'), Message(id: '2', content: 'B')])",
        "await actor.process('string literal')"
      ],
      "invalid_outputs": [
        "await actor.send(UnsafeMessage())",
        "await actor.send(mutableArray)",
        "var msg = Message(...); msg.content = 'new'; await actor.send(msg)"
      ],
      "tags": [
        "semantics",
        "sendable",
        "concurrency",
        "actors",
        "safety"
      ],
      "language": "swift",
      "domain": "semantics"
    },
    {
      "id": "swift-syntax-001",
      "name": "Codable Struct Schema for JSON",
      "description": "Generate Codable struct matching JSON schema",
      "scenario": "Developer creating a Swift struct to decode JSON API responses. The struct must conform to Codable protocol with property names and types matching the JSON structure, using CodingKeys for snake_case.",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n            \"type\": \"object\",\n            \"properties\": {\n                \"user_id\": {\"type\": \"string\"},\n                \"display_name\": {\"type\": \"string\"},\n                \"created_at\": {\"type\": \"string\", \"format\": \"date-time\"},\n                \"is_verified\": {\"type\": \"boolean\"}\n            },\n            \"required\": [\"user_id\", \"display_name\"]\n        }",
        "ebnf": "\n        root ::= \"struct User: Codable {\" ws properties ws coding-keys? ws \"}\"\n        properties ::= property+\n        property ::= \"let \" identifier \": \" type ws\n        coding-keys ::= \"enum CodingKeys: String, CodingKey {\" ws cases ws \"}\"\n        cases ::= case+\n        case ::= \"case \" identifier (\" = \" string)? ws\n        identifier ::= [a-z][a-zA-Z0-9]*\n        type ::= \"String\" | \"Bool\" | \"Date\" | \"Int\"\n        string ::= '\"' [^\"]* '\"'\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_aliases": {
          "Codable": "typealias Codable = Decodable & Encodable"
        }
      },
      "expected_effect": "Masks tokens that would create non-Codable properties or missing required fields. Ensures CodingKeys enum maps Swift camelCase to JSON snake_case.",
      "valid_outputs": [
        "struct User: Codable {\n    let userId: String\n    let displayName: String\n    let createdAt: Date\n    let isVerified: Bool\n    enum CodingKeys: String, CodingKey {\n        case userId = \"user_id\"\n        case displayName = \"display_name\"\n        case createdAt = \"created_at\"\n        case isVerified = \"is_verified\"\n    }\n}",
        "struct User: Codable {\n    let userId: String\n    let displayName: String\n}"
      ],
      "invalid_outputs": [
        "struct User { let userId: String }",
        "struct User: Codable { var userId: String }",
        "struct User: Codable { let user_id: String }"
      ],
      "tags": [
        "syntax",
        "codable",
        "json",
        "schema"
      ],
      "language": "swift",
      "domain": "syntax"
    },
    {
      "id": "swift-syntax-002",
      "name": "Bundle ID Regex Pattern",
      "description": "Validate iOS bundle identifier format",
      "scenario": "Developer configuring an iOS app bundle identifier. Must follow reverse DNS notation with lowercase alphanumeric segments separated by dots (e.g., com.company.appname).",
      "spec": {
        "version": "1.0",
        "regex": "^[a-z][a-z0-9]*(\\.[a-z][a-z0-9]*)+$",
        "ebnf": "\n        root ::= segment (\".\" segment)+\n        segment ::= [a-z] [a-z0-9]*\n        ",
        "language": "swift"
      },
      "expected_effect": "Masks tokens that would create invalid bundle IDs. Ensures lowercase, alphanumeric segments in reverse DNS format.",
      "valid_outputs": [
        "com.example.myapp",
        "com.company.productname",
        "io.github.username.project",
        "org.openai.chatapp"
      ],
      "invalid_outputs": [
        "MyApp",
        "com.Example.App",
        "com.company",
        "com.company.my-app",
        "com.company.my_app"
      ],
      "tags": [
        "syntax",
        "regex",
        "bundle-id",
        "validation"
      ],
      "language": "swift",
      "domain": "syntax"
    },
    {
      "id": "swift-syntax-003",
      "name": "SwiftUI DSL Structure",
      "description": "Enforce SwiftUI view hierarchy DSL syntax",
      "scenario": "Developer building SwiftUI views with proper DSL structure. Views must use containers (VStack, HStack, ZStack) with view builders, and modifiers must be chained in the correct order (frame before padding).",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= container | leaf-view\n        container ::= stack-type ws \"{\" ws view-list ws \"}\"\n        stack-type ::= \"VStack\" params? | \"HStack\" params? | \"ZStack\"\n        params ::= \"(\" param-list \")\"\n        param-list ::= identifier \":\" ws value (\",\" ws identifier \":\" ws value)*\n        view-list ::= view (ws view)*\n        view ::= (container | leaf-view) modifier*\n        leaf-view ::= \"Text(\" string \")\" | \"Image(\" image-param \")\" | \"Button(\" button-params \")\"\n        modifier ::= \".\" modifier-name \"(\" modifier-params? \")\"\n        modifier-name ::= \"padding\" | \"frame\" | \"background\" | \"foregroundColor\" | \"font\"\n        modifier-params ::= [^)]*\n        image-param ::= \"systemName: \" string | string\n        button-params ::= string \",\" ws \"action: {\" [^}]* \"}\"\n        identifier ::= [a-z][a-zA-Z0-9]*\n        value ::= number | \".\" identifier\n        string ::= '\"' [^\"]* '\"'\n        number ::= [0-9]+\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "some View",
            "scope": "local"
          }
        ],
        "type_aliases": {
          "View": "protocol { var body: some View }"
        }
      },
      "expected_effect": "Masks tokens that would violate SwiftUI DSL structure. Ensures proper container usage, view builder syntax, and modifier ordering.",
      "valid_outputs": [
        "VStack {\n    Text(\"Hello\")\n    Image(systemName: \"star\")\n}",
        "HStack(spacing: 10) {\n    Text(\"Left\").padding()\n    Text(\"Right\").padding()\n}.frame(width: 200)",
        "ZStack {\n    Text(\"Background\")\n    Text(\"Foreground\").foregroundColor(.blue)\n}"
      ],
      "invalid_outputs": [
        "VStack { print('debug'); Text('Hello') }",
        "Text('Hello') { Text('Child') }",
        "HStack([Text('A'), Text('B')])"
      ],
      "tags": [
        "syntax",
        "swiftui",
        "dsl",
        "view-builder"
      ],
      "language": "swift",
      "domain": "syntax"
    },
    {
      "id": "swift-actors-001",
      "name": "Actor Isolation with @MainActor",
      "description": "Deep dive: MainActor isolation for UI state management",
      "scenario": "Developer building a view model that manages UI state. All properties and methods must be @MainActor isolated to ensure UI updates happen on the main thread. Async methods can be called from any context but will automatically hop to MainActor.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= class-decl\n        class-decl ::= \"@MainActor\" ws \"class ViewModel: ObservableObject {\" ws members ws \"}\"\n        members ::= property+ ws method+\n        property ::= \"@Published var \" identifier \": \" type ws\n        method ::= \"func \" identifier params return-type? async? \"{\" ws body ws \"}\"\n        params ::= \"(\" (param (\",\" ws param)*)? \")\"\n        param ::= identifier \":\" ws type\n        return-type ::= \" -> \" type\n        async ::= \" async\"\n        body ::= statement+\n        statement ::= assignment | async-call | state-update\n        assignment ::= identifier \" = \" value ws\n        async-call ::= \"let \" identifier \" = await \" function-call ws\n        state-update ::= \"self.\" identifier \" = \" value ws\n        function-call ::= identifier \"()\"\n        identifier ::= [a-z][a-zA-Z0-9]*\n        type ::= \"[String]\" | \"Bool\" | \"Error?\" | \"Data\" | \"Void\"\n        value ::= \"true\" | \"false\" | \"nil\" | \"[\" \"]\" | identifier\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "@MainActor ViewModel",
            "scope": "local"
          }
        ],
        "class_definitions": [
          {
            "name": "ViewModel",
            "methods": [
              {
                "name": "loadData",
                "params": [],
                "return_type": "Void",
                "decorators": [
                  "@MainActor"
                ],
                "is_async": true
              },
              {
                "name": "updateUI",
                "params": [
                  {
                    "name": "data",
                    "type_expr": "Data"
                  }
                ],
                "return_type": "Void",
                "decorators": [
                  "@MainActor"
                ]
              }
            ],
            "instance_vars": [
              {
                "name": "items",
                "type_expr": "[String]"
              },
              {
                "name": "isLoading",
                "type_expr": "Bool"
              },
              {
                "name": "error",
                "type_expr": "Error?"
              }
            ]
          }
        ],
        "control_flow": {
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "All UI state mutations on MainActor",
            "scope": "ViewModel",
            "variables": [
              "items",
              "isLoading",
              "error"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would access MainActor-isolated state without proper isolation. Ensures all UI state is protected by @MainActor and async methods properly await when crossing isolation boundaries.",
      "valid_outputs": [
        "@MainActor\nclass ViewModel: ObservableObject {\n    @Published var items: [String] = []\n    @Published var isLoading = false\n\n    func loadData() async {\n        isLoading = true\n        let data = await fetchData()\n        items = data\n        isLoading = false\n    }\n}",
        "@MainActor\nclass ViewModel: ObservableObject {\n    @Published var items: [String] = []\n\n    nonisolated func startLoad() {\n        Task { @MainActor in\n            await loadData()\n        }\n    }\n\n    func loadData() async {\n        items = await fetchData()\n    }\n}"
      ],
      "invalid_outputs": [
        "class ViewModel: ObservableObject {\n    @Published var items: [String] = []\n    func loadData() async { items = await fetchData() }\n}",
        "@MainActor\nclass ViewModel: ObservableObject {\n    @Published var items: [String] = []\n    nonisolated func loadData() async { items = await fetchData() }\n}"
      ],
      "tags": [
        "actors",
        "main-actor",
        "isolation",
        "ui",
        "swiftui",
        "deep-dive"
      ],
      "language": "swift",
      "domain": "actors"
    },
    {
      "id": "swift-actors-002",
      "name": "Sendable Protocol Conformance",
      "description": "Deep dive: Sendable for safe cross-actor data transfer",
      "scenario": "Developer creating data models that will be passed between actors. Types must conform to Sendable to guarantee thread-safety. Value types are implicitly Sendable if all properties are Sendable. Classes need @unchecked Sendable or final + immutable properties.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= struct-def | class-def\n        struct-def ::= \"struct \" identifier \": Sendable {\" ws immutable-props ws \"}\"\n        class-def ::= \"final class \" identifier \": @unchecked Sendable {\" ws immutable-props ws \"}\"\n        immutable-props ::= immutable-prop+\n        immutable-prop ::= \"let \" identifier \": \" sendable-type ws\n        sendable-type ::= \"String\" | \"Int\" | \"UUID\" | \"Date\" | \"Bool\" | \"[\" sendable-type \"]\"\n        identifier ::= [A-Z][a-zA-Z0-9]*\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "class_definitions": [
          {
            "name": "Message",
            "instance_vars": [
              {
                "name": "id",
                "type_expr": "UUID",
                "mutable": false
              },
              {
                "name": "content",
                "type_expr": "String",
                "mutable": false
              },
              {
                "name": "timestamp",
                "type_expr": "Date",
                "mutable": false
              }
            ]
          }
        ],
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "All properties are Sendable and immutable",
            "scope": "Message",
            "variables": [
              "id",
              "content",
              "timestamp"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would create non-Sendable types (mutable properties, non-final classes, closures capturing mutable state). Ensures safe cross-actor communication.",
      "valid_outputs": [
        "struct Message: Sendable {\n    let id: UUID\n    let content: String\n    let timestamp: Date\n}",
        "final class Message: @unchecked Sendable {\n    let id: UUID\n    let content: String\n    init(id: UUID, content: String) {\n        self.id = id\n        self.content = content\n    }\n}",
        "struct Container: Sendable {\n    let items: [String]\n    let metadata: [String: Int]\n}"
      ],
      "invalid_outputs": [
        "struct Message: Sendable {\n    var content: String\n}",
        "class Message: Sendable {\n    let content: String\n}",
        "struct Message: Sendable {\n    let handler: () -> Void\n}"
      ],
      "tags": [
        "actors",
        "sendable",
        "concurrency",
        "thread-safety",
        "deep-dive"
      ],
      "language": "swift",
      "domain": "actors"
    },
    {
      "id": "swift-actors-003",
      "name": "Task Groups with Async/Await",
      "description": "Deep dive: Structured concurrency with TaskGroup for parallel operations",
      "scenario": "Developer implementing parallel async operations using TaskGroup. Must properly add child tasks, await results, and handle errors. All child tasks must return Sendable types to safely collect results.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= \"await withTaskGroup(of: \" type \".self) { group in\" ws body ws \"}\"\n        body ::= add-tasks ws collect-results\n        add-tasks ::= \"for url in urls {\" ws \"group.addTask { await fetch(url) }\" ws \"}\"\n        collect-results ::= \"var results: [\" type \"] = []\" ws\n                           \"for await result in group {\" ws\n                           \"results.append(result)\" ws\n                           \"}\" ws\n                           \"return results\"\n        type ::= \"Data\" | \"String\" | \"Int\"\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "urls",
            "type_expr": "[URL]",
            "scope": "parameter"
          }
        ],
        "control_flow": {
          "function_name": "fetchAll",
          "function_signature": {
            "name": "fetchAll",
            "params": [
              {
                "name": "urls",
                "type_expr": "[URL]"
              }
            ],
            "return_type": "[Data]",
            "is_async": true
          },
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "precondition",
            "expression": "Result type is Sendable",
            "scope": "withTaskGroup",
            "variables": [
              "Data"
            ]
          },
          {
            "kind": "postcondition",
            "expression": "All tasks completed or cancelled",
            "scope": "fetchAll"
          }
        ]
      },
      "expected_effect": "Masks tokens that would create TaskGroup with non-Sendable types, forget to await results, or improperly handle task lifecycle. Ensures structured concurrency with proper cleanup.",
      "valid_outputs": [
        "await withTaskGroup(of: Data.self) { group in\n    for url in urls {\n        group.addTask { await fetch(url) }\n    }\n    var results: [Data] = []\n    for await result in group {\n        results.append(result)\n    }\n    return results\n}",
        "await withThrowingTaskGroup(of: Data.self) { group in\n    for url in urls {\n        group.addTask { try await fetch(url) }\n    }\n    var results: [Data] = []\n    for try await result in group {\n        results.append(result)\n    }\n    return results\n}",
        "await withTaskGroup(of: Data?.self) { group in\n    urls.forEach { url in\n        group.addTask { await fetch(url) }\n    }\n    return await group.reduce(into: [Data]()) { results, data in\n        if let data = data { results.append(data) }\n    }\n}"
      ],
      "invalid_outputs": [
        "withTaskGroup(of: Data.self) { group in\n    // Missing await\n    return []\n}",
        "await withTaskGroup(of: NSMutableData.self) { group in\n    // NSMutableData is not Sendable\n    return []\n}",
        "await withTaskGroup(of: Data.self) { group in\n    for url in urls {\n        Task { await fetch(url) }  // Wrong: detached task, not grouped\n    }\n}"
      ],
      "tags": [
        "actors",
        "task-group",
        "async",
        "await",
        "parallel",
        "deep-dive"
      ],
      "language": "swift",
      "domain": "actors"
    },
    {
      "id": "swift-actors-004",
      "name": "Actor Reentrancy and State Races",
      "description": "Deep dive: Understanding actor reentrancy across suspension points",
      "scenario": "Developer implementing actor methods with suspension points. Must understand that actor state can change between suspension points due to reentrancy. Need to capture state before await and validate after.",
      "spec": {
        "version": "1.0",
        "ebnf": "\n        root ::= actor-def\n        actor-def ::= \"actor Counter {\" ws state ws method ws \"}\"\n        state ::= \"private var value: Int = 0\" ws\n        method ::= \"func incrementSlowly() async {\" ws\n                  \"let before = value\" ws\n                  \"await Task.sleep(nanoseconds: 100_000)\" ws\n                  \"let after = value\" ws\n                  \"value = after + 1\" ws\n                  \"precondition(after >= before, \" string \")\" ws\n                  \"}\"\n        string ::= '\"' [^\"]* '\"'\n        ws ::= (\" \" | \"\\n\")*\n        ",
        "language": "swift",
        "type_bindings": [
          {
            "name": "self",
            "type_expr": "actor Counter",
            "scope": "local"
          },
          {
            "name": "value",
            "type_expr": "Int",
            "scope": "local"
          }
        ],
        "control_flow": {
          "function_name": "incrementSlowly",
          "in_async_context": true
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "value >= 0",
            "scope": "Counter",
            "variables": [
              "value"
            ]
          },
          {
            "kind": "assertion",
            "expression": "Captured state before suspension, validated after",
            "scope": "incrementSlowly",
            "variables": [
              "value"
            ]
          }
        ]
      },
      "expected_effect": "Masks tokens that would ignore reentrancy concerns. Ensures developers capture state before suspension, validate after, and handle potential races.",
      "valid_outputs": [
        "actor Counter {\n    private var value: Int = 0\n\n    func incrementSlowly() async {\n        let before = value\n        await Task.sleep(nanoseconds: 100_000)\n        let after = value\n        value = after + 1\n        precondition(after >= before, \"Value decreased during suspension\")\n    }\n}",
        "actor BankAccount {\n    private var balance: Int = 0\n\n    func withdraw(_ amount: Int) async -> Bool {\n        let currentBalance = balance\n        await validateWithServer(amount)\n        guard balance >= amount else { return false }\n        precondition(balance <= currentBalance, \"Balance increased unexpectedly\")\n        balance -= amount\n        return true\n    }\n}"
      ],
      "invalid_outputs": [
        "actor Counter {\n    private var value: Int = 0\n    func incrementSlowly() async {\n        await Task.sleep(nanoseconds: 100_000)\n        value += 1  // Race: value could have changed\n    }\n}",
        "actor Counter {\n    private var value: Int = 0\n    func incrementSlowly() async {\n        value += 1\n        await Task.sleep(nanoseconds: 100_000)\n        // No validation after suspension\n    }\n}"
      ],
      "tags": [
        "actors",
        "reentrancy",
        "suspension",
        "race-conditions",
        "deep-dive"
      ],
      "language": "swift",
      "domain": "actors"
    },
    {
      "id": "cross-api-python",
      "name": "Python API Response Handler",
      "description": "Parse and validate API response with Pydantic model and type hints",
      "scenario": "Developer writing an async API client that deserializes JSON responses into typed models",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\"type\": \"string\", \"enum\": [\"success\", \"error\"]},\n        \"data\": {\"type\": \"object\"},\n        \"error\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"code\": {\"type\": \"integer\"},\n                \"message\": {\"type\": \"string\"}\n            }\n        },\n        \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"}\n    },\n    \"required\": [\"status\", \"timestamp\"],\n    \"if\": {\"properties\": {\"status\": {\"const\": \"success\"}}},\n    \"then\": {\"required\": [\"data\"]},\n    \"else\": {\"required\": [\"error\"]}\n}",
        "language": "python",
        "type_bindings": [
          {
            "name": "response",
            "type_expr": "httpx.Response",
            "scope": "parameter"
          },
          {
            "name": "model_cls",
            "type_expr": "Type[T]",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "parse_response",
            "params": [
              {
                "name": "response",
                "type_expr": "httpx.Response"
              },
              {
                "name": "model_cls",
                "type_expr": "Type[T]"
              }
            ],
            "return_type": "ApiResponse[T]",
            "type_params": [
              "T"
            ],
            "is_async": true
          }
        ],
        "expected_type": "ApiResponse[T]",
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "result.status in ('success', 'error')",
            "scope": "parse_response"
          }
        ]
      },
      "expected_effect": "Ensures response conforms to ApiResponse schema with proper status field",
      "valid_outputs": [
        "return ApiResponse(status=\"success\", data=model_cls(**json_data), timestamp=datetime.now())",
        "return ApiResponse.model_validate(response.json())"
      ],
      "invalid_outputs": [
        "return {\"status\": \"ok\"}",
        "return json_data"
      ],
      "tags": [
        "api",
        "json",
        "async",
        "generics",
        "cross-language"
      ],
      "language": "python",
      "domain": "syntax"
    },
    {
      "id": "cross-api-rust",
      "name": "Rust API Response Handler",
      "description": "Deserialize API response with serde and Result error handling",
      "scenario": "Developer writing an async HTTP client with typed JSON deserialization",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\"type\": \"string\", \"enum\": [\"success\", \"error\"]},\n        \"data\": {\"type\": \"object\"},\n        \"error\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"code\": {\"type\": \"integer\"},\n                \"message\": {\"type\": \"string\"}\n            }\n        },\n        \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"}\n    },\n    \"required\": [\"status\", \"timestamp\"],\n    \"if\": {\"properties\": {\"status\": {\"const\": \"success\"}}},\n    \"then\": {\"required\": [\"data\"]},\n    \"else\": {\"required\": [\"error\"]}\n}",
        "language": "rust",
        "type_bindings": [
          {
            "name": "response",
            "type_expr": "reqwest::Response",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "parse_response",
            "params": [
              {
                "name": "response",
                "type_expr": "reqwest::Response"
              }
            ],
            "return_type": "Result<ApiResponse<T>, ApiError>",
            "type_params": [
              "T: DeserializeOwned"
            ],
            "is_async": true
          }
        ],
        "expected_type": "Result<ApiResponse<T>, ApiError>",
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "result.is_ok() implies result.unwrap().status.is_valid()",
            "scope": "parse_response"
          }
        ]
      },
      "expected_effect": "Ensures proper Result wrapping and serde deserialization",
      "valid_outputs": [
        "let data: ApiResponse<T> = response.json().await?; Ok(data)",
        "response.json::<ApiResponse<T>>().await.map_err(ApiError::from)"
      ],
      "invalid_outputs": [
        "response.json().await.unwrap()",
        "Ok(response.text().await?)"
      ],
      "tags": [
        "api",
        "json",
        "async",
        "result",
        "cross-language"
      ],
      "language": "rust",
      "domain": "syntax"
    },
    {
      "id": "cross-api-typescript",
      "name": "TypeScript API Response Handler",
      "description": "Fetch API response with type guards and discriminated unions",
      "scenario": "Developer writing a typed fetch wrapper with proper error discrimination",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\"type\": \"string\", \"enum\": [\"success\", \"error\"]},\n        \"data\": {\"type\": \"object\"},\n        \"error\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"code\": {\"type\": \"integer\"},\n                \"message\": {\"type\": \"string\"}\n            }\n        },\n        \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"}\n    },\n    \"required\": [\"status\", \"timestamp\"],\n    \"if\": {\"properties\": {\"status\": {\"const\": \"success\"}}},\n    \"then\": {\"required\": [\"data\"]},\n    \"else\": {\"required\": [\"error\"]}\n}",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "response",
            "type_expr": "Response",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "parseResponse",
            "params": [
              {
                "name": "response",
                "type_expr": "Response"
              }
            ],
            "return_type": "Promise<ApiResponse<T>>",
            "type_params": [
              "T"
            ],
            "is_async": true
          }
        ],
        "expected_type": "Promise<ApiResponse<T>>"
      },
      "expected_effect": "Ensures proper async/await and type narrowing for response status",
      "valid_outputs": [
        "const json = await response.json(); return validateApiResponse<T>(json);",
        "return response.json() as Promise<ApiResponse<T>>;"
      ],
      "invalid_outputs": [
        "return response.json();",
        "return { status: 'ok' };"
      ],
      "tags": [
        "api",
        "json",
        "async",
        "generics",
        "cross-language"
      ],
      "language": "typescript",
      "domain": "syntax"
    },
    {
      "id": "cross-api-go",
      "name": "Go API Response Handler",
      "description": "Unmarshal JSON response with proper error handling idioms",
      "scenario": "Developer writing an HTTP client with json.Unmarshal and error checks",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\"type\": \"string\", \"enum\": [\"success\", \"error\"]},\n        \"data\": {\"type\": \"object\"},\n        \"error\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"code\": {\"type\": \"integer\"},\n                \"message\": {\"type\": \"string\"}\n            }\n        },\n        \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"}\n    },\n    \"required\": [\"status\", \"timestamp\"],\n    \"if\": {\"properties\": {\"status\": {\"const\": \"success\"}}},\n    \"then\": {\"required\": [\"data\"]},\n    \"else\": {\"required\": [\"error\"]}\n}",
        "language": "go",
        "type_bindings": [
          {
            "name": "resp",
            "type_expr": "*http.Response",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "ParseResponse",
            "params": [
              {
                "name": "resp",
                "type_expr": "*http.Response"
              }
            ],
            "return_type": "(*ApiResponse[T], error)",
            "type_params": [
              "T"
            ]
          }
        ],
        "expected_type": "(*ApiResponse[T], error)",
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "err == nil implies result.Status != ''",
            "scope": "ParseResponse"
          }
        ]
      },
      "expected_effect": "Ensures proper error return pattern and defer body.Close()",
      "valid_outputs": [
        "defer resp.Body.Close(); var result ApiResponse[T]; if err := json.NewDecoder(resp.Body).Decode(&result); err != nil { return nil, err }; return &result, nil"
      ],
      "invalid_outputs": [
        "json.Unmarshal(body, &result)",
        "return result"
      ],
      "tags": [
        "api",
        "json",
        "error-handling",
        "cross-language"
      ],
      "language": "go",
      "domain": "syntax"
    },
    {
      "id": "cross-api-zig",
      "name": "Zig API Response Handler",
      "description": "Parse JSON response with error unions and allocator management",
      "scenario": "Developer writing an HTTP client with std.json parsing",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\"type\": \"string\", \"enum\": [\"success\", \"error\"]},\n        \"data\": {\"type\": \"object\"},\n        \"error\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"code\": {\"type\": \"integer\"},\n                \"message\": {\"type\": \"string\"}\n            }\n        },\n        \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"}\n    },\n    \"required\": [\"status\", \"timestamp\"],\n    \"if\": {\"properties\": {\"status\": {\"const\": \"success\"}}},\n    \"then\": {\"required\": [\"data\"]},\n    \"else\": {\"required\": [\"error\"]}\n}",
        "language": "zig",
        "type_bindings": [
          {
            "name": "allocator",
            "type_expr": "std.mem.Allocator",
            "scope": "parameter"
          },
          {
            "name": "body",
            "type_expr": "[]const u8",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "parseResponse",
            "params": [
              {
                "name": "allocator",
                "type_expr": "std.mem.Allocator"
              },
              {
                "name": "body",
                "type_expr": "[]const u8"
              }
            ],
            "return_type": "!ApiResponse(T)",
            "type_params": [
              "T"
            ]
          }
        ],
        "expected_type": "!ApiResponse(T)"
      },
      "expected_effect": "Ensures proper error union handling and allocator usage",
      "valid_outputs": [
        "const parsed = try std.json.parseFromSlice(ApiResponse(T), allocator, body, .{}); return parsed.value;"
      ],
      "invalid_outputs": [
        "std.json.parseFromSlice(ApiResponse(T), allocator, body, .{}).value"
      ],
      "tags": [
        "api",
        "json",
        "error-union",
        "allocator",
        "cross-language"
      ],
      "language": "zig",
      "domain": "syntax"
    },
    {
      "id": "cross-api-kotlin",
      "name": "Kotlin API Response Handler",
      "description": "Parse JSON response with kotlinx.serialization in suspend context",
      "scenario": "Developer writing a Ktor client with typed JSON deserialization",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\"type\": \"string\", \"enum\": [\"success\", \"error\"]},\n        \"data\": {\"type\": \"object\"},\n        \"error\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"code\": {\"type\": \"integer\"},\n                \"message\": {\"type\": \"string\"}\n            }\n        },\n        \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"}\n    },\n    \"required\": [\"status\", \"timestamp\"],\n    \"if\": {\"properties\": {\"status\": {\"const\": \"success\"}}},\n    \"then\": {\"required\": [\"data\"]},\n    \"else\": {\"required\": [\"error\"]}\n}",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "response",
            "type_expr": "HttpResponse",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "parseResponse",
            "params": [
              {
                "name": "response",
                "type_expr": "HttpResponse"
              }
            ],
            "return_type": "ApiResponse<T>",
            "type_params": [
              "T"
            ],
            "is_async": true
          }
        ],
        "expected_type": "ApiResponse<T>"
      },
      "expected_effect": "Ensures suspend function usage and proper serialization",
      "valid_outputs": [
        "return response.body<ApiResponse<T>>()",
        "val json = response.bodyAsText(); return Json.decodeFromString<ApiResponse<T>>(json)"
      ],
      "invalid_outputs": [
        "return response.body()",
        "Json.decodeFromString(json)"
      ],
      "tags": [
        "api",
        "json",
        "coroutines",
        "serialization",
        "cross-language"
      ],
      "language": "kotlin",
      "domain": "syntax"
    },
    {
      "id": "cross-api-swift",
      "name": "Swift API Response Handler",
      "description": "Decode JSON response with Codable protocol in async context",
      "scenario": "Developer writing a URLSession-based client with typed decoding",
      "spec": {
        "version": "1.0",
        "json_schema": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\"type\": \"string\", \"enum\": [\"success\", \"error\"]},\n        \"data\": {\"type\": \"object\"},\n        \"error\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"code\": {\"type\": \"integer\"},\n                \"message\": {\"type\": \"string\"}\n            }\n        },\n        \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"}\n    },\n    \"required\": [\"status\", \"timestamp\"],\n    \"if\": {\"properties\": {\"status\": {\"const\": \"success\"}}},\n    \"then\": {\"required\": [\"data\"]},\n    \"else\": {\"required\": [\"error\"]}\n}",
        "language": "swift",
        "type_bindings": [
          {
            "name": "data",
            "type_expr": "Data",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "parseResponse",
            "params": [
              {
                "name": "data",
                "type_expr": "Data"
              }
            ],
            "return_type": "ApiResponse<T>",
            "type_params": [
              "T: Decodable"
            ],
            "is_async": true
          }
        ],
        "expected_type": "ApiResponse<T>"
      },
      "expected_effect": "Ensures proper Codable usage and throwing function pattern",
      "valid_outputs": [
        "let decoder = JSONDecoder(); return try decoder.decode(ApiResponse<T>.self, from: data)",
        "return try JSONDecoder().decode(ApiResponse<T>.self, from: data)"
      ],
      "invalid_outputs": [
        "JSONDecoder().decode(ApiResponse.self, from: data)",
        "return data as? ApiResponse<T>"
      ],
      "tags": [
        "api",
        "json",
        "async",
        "codable",
        "cross-language"
      ],
      "language": "swift",
      "domain": "syntax"
    },
    {
      "id": "cross-error-python",
      "name": "Python Resource Error Handler",
      "description": "Handle file operations with context managers and exception chaining",
      "scenario": "Developer writing a file processor with proper resource cleanup",
      "spec": {
        "version": "1.0",
        "language": "python",
        "type_bindings": [
          {
            "name": "path",
            "type_expr": "Path",
            "scope": "parameter"
          }
        ],
        "expected_type": "Optional[str]",
        "control_flow": {
          "function_name": "read_config",
          "expected_return_type": "Optional[str]",
          "in_try_block": true,
          "exception_types": [
            "FileNotFoundError",
            "PermissionError",
            "json.JSONDecodeError"
          ]
        },
        "semantic_constraints": [
          {
            "kind": "postcondition",
            "expression": "result is None or isinstance(result, str)",
            "scope": "read_config"
          }
        ]
      },
      "expected_effect": "Ensures proper exception handling and resource cleanup",
      "valid_outputs": [
        "with open(path) as f: return f.read()",
        "try: return path.read_text() except FileNotFoundError: return None"
      ],
      "invalid_outputs": [
        "return open(path).read()",
        "f = open(path); return f.read()"
      ],
      "tags": [
        "error-handling",
        "context-manager",
        "exceptions",
        "cross-language"
      ],
      "language": "python",
      "domain": "controlflow"
    },
    {
      "id": "cross-error-rust",
      "name": "Rust Result Error Handler",
      "description": "Propagate errors with ? operator and custom error types",
      "scenario": "Developer writing a config loader with proper error propagation",
      "spec": {
        "version": "1.0",
        "language": "rust",
        "type_bindings": [
          {
            "name": "path",
            "type_expr": "&Path",
            "scope": "parameter"
          }
        ],
        "expected_type": "Result<Config, ConfigError>",
        "forbidden_imports": [
          "std::panic"
        ],
        "control_flow": {
          "function_name": "read_config",
          "expected_return_type": "Result<Config, ConfigError>"
        },
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "no unwrap() or expect() calls",
            "scope": "read_config"
          }
        ]
      },
      "expected_effect": "Ensures ? operator usage, no unwrap/expect, proper From impls",
      "valid_outputs": [
        "let content = fs::read_to_string(path)?; let config: Config = serde_json::from_str(&content)?; Ok(config)",
        "fs::read_to_string(path).map_err(ConfigError::Io).and_then(|s| serde_json::from_str(&s).map_err(ConfigError::Parse))"
      ],
      "invalid_outputs": [
        "fs::read_to_string(path).unwrap()",
        "fs::read_to_string(path).expect(\"file\")"
      ],
      "tags": [
        "error-handling",
        "result",
        "question-mark",
        "cross-language"
      ],
      "language": "rust",
      "domain": "controlflow"
    },
    {
      "id": "cross-error-typescript",
      "name": "TypeScript Result Type Handler",
      "description": "Handle errors with discriminated union Result type pattern",
      "scenario": "Developer implementing a typed Result pattern for type-safe error handling",
      "spec": {
        "version": "1.0",
        "language": "typescript",
        "type_bindings": [
          {
            "name": "path",
            "type_expr": "string",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "readConfig",
            "params": [
              {
                "name": "path",
                "type_expr": "string"
              }
            ],
            "return_type": "Promise<Result<Config, ConfigError>>",
            "is_async": true
          }
        ],
        "expected_type": "Result<Config, ConfigError>"
      },
      "expected_effect": "Ensures proper Result type usage with ok/err discriminator",
      "valid_outputs": [
        "try { const content = await fs.readFile(path, 'utf-8'); return { ok: true, value: JSON.parse(content) }; } catch (e) { return { ok: false, error: new ConfigError(e) }; }"
      ],
      "invalid_outputs": [
        "return JSON.parse(await fs.readFile(path, 'utf-8'))",
        "return { value: config }"
      ],
      "tags": [
        "error-handling",
        "result-type",
        "discriminated-union",
        "cross-language"
      ],
      "language": "typescript",
      "domain": "controlflow"
    },
    {
      "id": "cross-error-go",
      "name": "Go Error Return Handler",
      "description": "Handle errors with Go's idiomatic (value, error) return pattern",
      "scenario": "Developer writing a config loader following Go error conventions",
      "spec": {
        "version": "1.0",
        "language": "go",
        "type_bindings": [
          {
            "name": "path",
            "type_expr": "string",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "ReadConfig",
            "params": [
              {
                "name": "path",
                "type_expr": "string"
              }
            ],
            "return_type": "(*Config, error)"
          }
        ],
        "expected_type": "(*Config, error)",
        "semantic_constraints": [
          {
            "kind": "invariant",
            "expression": "every error is checked immediately after call",
            "scope": "ReadConfig"
          }
        ]
      },
      "expected_effect": "Ensures if err != nil pattern and proper error wrapping",
      "valid_outputs": [
        "data, err := os.ReadFile(path); if err != nil { return nil, fmt.Errorf(\"reading config: %w\", err) }; var cfg Config; if err := json.Unmarshal(data, &cfg); err != nil { return nil, err }; return &cfg, nil"
      ],
      "invalid_outputs": [
        "data, _ := os.ReadFile(path)",
        "return &cfg"
      ],
      "tags": [
        "error-handling",
        "multi-return",
        "error-wrapping",
        "cross-language"
      ],
      "language": "go",
      "domain": "controlflow"
    },
    {
      "id": "cross-error-zig",
      "name": "Zig Error Union Handler",
      "description": "Handle errors with error unions and errdefer cleanup",
      "scenario": "Developer writing a config loader with proper resource cleanup on error",
      "spec": {
        "version": "1.0",
        "language": "zig",
        "type_bindings": [
          {
            "name": "allocator",
            "type_expr": "std.mem.Allocator",
            "scope": "parameter"
          },
          {
            "name": "path",
            "type_expr": "[]const u8",
            "scope": "parameter"
          }
        ],
        "expected_type": "ConfigError!Config",
        "control_flow": {
          "function_name": "readConfig",
          "expected_return_type": "ConfigError!Config"
        }
      },
      "expected_effect": "Ensures try/catch usage, errdefer for cleanup, proper error propagation",
      "valid_outputs": [
        "const file = try std.fs.cwd().openFile(path, .{}); errdefer file.close(); const content = try file.readToEndAlloc(allocator, max_size); return parseConfig(content);"
      ],
      "invalid_outputs": [
        "std.fs.cwd().openFile(path, .{}).file",
        "const file = try std.fs.cwd().openFile(path, .{});"
      ],
      "tags": [
        "error-handling",
        "error-union",
        "errdefer",
        "cross-language"
      ],
      "language": "zig",
      "domain": "controlflow"
    },
    {
      "id": "cross-error-kotlin",
      "name": "Kotlin Result Error Handler",
      "description": "Handle errors with Kotlin's Result type and runCatching",
      "scenario": "Developer writing a config loader with functional error handling",
      "spec": {
        "version": "1.0",
        "language": "kotlin",
        "type_bindings": [
          {
            "name": "path",
            "type_expr": "Path",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "readConfig",
            "params": [
              {
                "name": "path",
                "type_expr": "Path"
              }
            ],
            "return_type": "Result<Config>"
          }
        ],
        "expected_type": "Result<Config>"
      },
      "expected_effect": "Ensures Result type usage with map/recover chains",
      "valid_outputs": [
        "return runCatching { path.readText() }.mapCatching { Json.decodeFromString<Config>(it) }",
        "return runCatching { Json.decodeFromString<Config>(path.readText()) }"
      ],
      "invalid_outputs": [
        "return Config(path.readText())",
        "try { return Result.success(parse(path)) } catch (e: Exception) { throw e }"
      ],
      "tags": [
        "error-handling",
        "result-type",
        "runCatching",
        "cross-language"
      ],
      "language": "kotlin",
      "domain": "controlflow"
    },
    {
      "id": "cross-error-swift",
      "name": "Swift Result Error Handler",
      "description": "Handle errors with Swift's Result type and throwing functions",
      "scenario": "Developer writing a config loader with proper error propagation",
      "spec": {
        "version": "1.0",
        "language": "swift",
        "type_bindings": [
          {
            "name": "path",
            "type_expr": "URL",
            "scope": "parameter"
          }
        ],
        "function_signatures": [
          {
            "name": "readConfig",
            "params": [
              {
                "name": "path",
                "type_expr": "URL"
              }
            ],
            "return_type": "Result<Config, ConfigError>"
          }
        ],
        "expected_type": "Result<Config, ConfigError>"
      },
      "expected_effect": "Ensures Result type with mapError and flatMap",
      "valid_outputs": [
        "return Result { try Data(contentsOf: path) }.flatMap { data in Result { try JSONDecoder().decode(Config.self, from: data) } }.mapError { ConfigError.underlying($0) }",
        "do { let data = try Data(contentsOf: path); let config = try JSONDecoder().decode(Config.self, from: data); return .success(config) } catch { return .failure(.underlying(error)) }"
      ],
      "invalid_outputs": [
        "return .success(try JSONDecoder().decode(Config.self, from: Data(contentsOf: path)))",
        "try! Data(contentsOf: path)"
      ],
      "tags": [
        "error-handling",
        "result-type",
        "throwing",
        "cross-language"
      ],
      "language": "swift",
      "domain": "controlflow"
    }
  ]
}